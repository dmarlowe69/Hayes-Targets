Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-1


				page 60, 132
				
				;   SWAP.ASM        Version 3.00    October 4, 1990
				;
				;   Contains code and data needed to swap most of the current program out
				;   to extended memory, expanded memory, or disk; execute another program;
				;   and re-load the original program back into memory.
				;
				;   Copyright (C) 1990 by Marty Del Vecchio
				;   Released to the public domain for free use by all
				;   Product is supplied as is and author disclaims all warranties,
				;   explicit or implied, about the functionality of the source code
				;   or object modules supplied, and shall not be held responsible
				;   for any damages caused by use of product.
				;
				;   Code to parse default FCB's written and generously donated
				;   by David E. Jenkins (jenkins@wang.com or dave.jenkins@office.wang.com).
				;
				;   Contributions not solicited.  Just appreciate the fact that somebody
				;   took the time to write and comment this code.  If you have any
				;   questions, please contact me at:
				;
				;   Marty Del Vecchio                   Channel 1 BBS
				;   99 Marlboro Road                    Boston, MA
				;   Southborough, MA  01772             (617) 354-8873
				;   (508) 485-9718
				;
				;   internet:  marty@bsn.mceo.dg.com
				;
				;   For information about the contents of this file, see the accompanying
				;   file SWAP.DOC.
				;
				
				
				; 'DOSSEG' gives us support for Microsoft C and Turbo C segment naming
				; and ordering schemes
				DOSSEG
				
				; Figure out which memory model we're assembling for.  Specified on
				;  MASM command line with /D followed by either _Small, _Compact, _Medium,
				;  or _Large.  If none specified, _Small is assumed.
				
				; Once the model is defined, MASM provides two definitions, @codesize
				;  and @datasize, to determine the size of code and data pointers.  If
				;  @codesize is 0 (Small and Compact), there is one code segment, and
				;  code addresses are 16 bits (offset only).  If @codesize is 1 (Medium
				;  and Large), there are multiple code segments, and code addresses are
				;  32 bits (segment and offset).  Similarly, @datasize of 0 means one
				;  data segment (16-bit pointers), and @datasize of 1 means multiple
				;  data segments (32-bit pointers).
				
				 ELSE
				   ELSE
				      IFDEF _medium
				         .MODEL Medium, C
				      ENDIF
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-2


				   ENDIF
				ENDIF
				
				; Report whether multiple DOS memory blocks will be swapped
				
				; Figure out which save method we are using--EMS, XMS, disk, or a
				;  combination.
				
				; Specified on MASM command line with /D followed by either "xms", "ems",
				;  "disk", or "all".  For example, to create a swap() that will try using
				;  XMS and EMS, you would use "masm swap.asm /Dems /Dxms".
				
				; If none specified, it will use all.  To change the order in which swap()
				;  attempts to save the program to different places, see the function
				;  save_program below.
				
				; First, see if they want all of them...
				ELSE
				   ; /Dall not specified--try each individually...
				
				
				
				ENDIF
				
				; Now see if they declared anything--if not, it will use them all
				
				; Constant definitions for easier reading
 = 0002				STDERR          equ     2           ; Standard DOS file handle for error output
 = 0035				GET_VECTOR      equ     35h         ; DOS function to get interrupt vector
 = 0067				EMM_INT         equ     67h         ; EMS interrupt vector
 = 0008				EMM_NAME_LEN    equ     8           ; Length of EMS device driver name
 = 007F				MAX_DOS_CMD     equ     127         ; Maximum DOS command-line length
				
				; If we will swap out all DOS memory blocks a program owns, we need a
				;   place to store information about them
 = 0010				MAX_EXTRA       equ     16          ; Maximum number of extra DOS allocation blocks to swap
				
				dos_block       struc               ; Structure for extra DOS memory blocks
 0000  0000			block_seg       dw      0           ; User's segment address of block
 0002  0000			block_size      dw      0           ; Size in paragraphs of block
 0004				dos_block       ends
				
				
 = byte ptr			bptr            equ     byte ptr    ; Means we're loading/storing 8 bits
 = word ptr			wptr            equ     word ptr    ; Means we're loading/storing 16 bits
 = dword ptr			dptr            equ     dword ptr   ; Means we're loading/storing 32 bits
				
				
				; All code and data must be in the code segment, which is the first segment
				;  in all Turbo C, Turbo C++, and Microsoft C memory models.
				
				; If we are in the Medium or Large models, there are multiple code segments.
				;  If this is the case, our default code segment name will be "SWAP_TEXT".
				;  This is acceptable in most cases, except when using the Turbo C integrated
				;  development environment.  See SWAP.DOC for details.
				
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-3


				; If you are using Turbo C's Integrated Development Environment, the line
				;  right after "IF @codesize" MUST say ".CODE  _TEXT"!!!!!!!!!!!!!!!!!!!!
				
				 ELSE
				
					IF @codesize
					.CODE	 SWAP_TEXT
					ENDIF
				
				 ENDIF
				
				; *****************************************************************************
				; Our resident data declarations--this data will be needed after the swap
				;  has occurred, and thus must be above the resident line
				; *****************************************************************************
				
				; *****************************************************************************
				; First, all variables that will be used by all versions assembled from
				; this source file, regardless of what save options are selected
				; *****************************************************************************
 0000  0000			ret_code    dw      0           ; Return code (to C caller) of this swap routine
				                                ;   0 = success
				                                ;   1 = unable to shrink DOS memory allocation
				                                ;   2 = unable to save program to EMS
				                                ;   3 = unable to execute requested program
				                                ; These values must be the same as those listed
				                                ;  in SWAP.H!!!!!!!!!
				
				; *****************************************************************************
				; Variables that deal with DOS' memory allocation blocks
 0002  0000			old_size    dw      0           ; The old size (in paragraphs) of this program
 0004  0000			new_size    dw      0           ; The new "resident" size, doesn't include code/data swapped
 0006  0000			prog_size   dw      0           ; Size in paragraphs of saved part of program block (old_size - new_
				size)
 0008  0000			total_paras dw      0           ; Size (in paragraphs) of all blocks combined
 000A  0000			my_psp      dw      0           ; This program's Program Segment Prefix (PSP)
 000C  0000			mcb_psp     dw      0           ; The PSP address in this program's memory block
 000E  0000			start_seg   dw      0           ; Segment address of released memory
				
				; If we are swapping all DOS memory blocks a program owns, we store
				;  them in this array of structures
				IFNDEF NOFRAG
 0010  0000			extra_count dw      0           ; # of extra blocks to save (not including program block)
 0012  0010[			dos_blocks  dos_block MAX_EXTRA dup (<>)    ; Array for extra blocks
	   0000			
	   0000			
			 ]	
				
				ENDIF
				; *****************************************************************************
				
				; *****************************************************************************
				; Variable used during the save/restore process
 0052  0000			handle      dw      0           ; EMS/XMS/disk file handle
				; *****************************************************************************
				
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-4


				; *****************************************************************************
				; A temporary stack in our code segment, and associated variables
 0054  0000			old_sp      dw      0               ; Place to save this program's stack
 0056  0000			old_ss      dw      0               ;  information while executing new program
				
				; XMS driver needs a large stack (at least 256 bytes free when called)
				IFDEF USE_XMS
 0058  0140[			new_stack   db      320 dup ('?')   ; Temporary stack we can address after swap
	   3F			
			 ]	
				
				ENDIF
 0198				new_sp      label   word            ; Point SP to "top" of stack
				; *****************************************************************************
				
				; *****************************************************************************
				; Variables that deal with the execution of the new program
 0198  0080[			prog_name   db      128 dup (0)     ; Storage for name of program to execute
	   00			
			 ]	
				
 0218  00			cmd_pad     db      0               ; Maintain word-alignment for variables
 0219  00			cmd_len     db      0               ; Storage for length of command line parameters
 021A  0080[			cmd_line    db      128 dup (0)     ; Storage for command line parameters
	   00			
			 ]	
				
				
 029A				param_blk   label   byte            ; Program Parameter Block--pass to DOS on exec call
 029A  0000			env_seg     dw      0               ; Environment segment address, 0 means a COPY of ours
 029C  0219 R			cmd_ofs     dw      offset @code:cmd_len    ; Offset address of command line
 029E  ---- R			cmd_seg     dw      seg cmd_line    ; Segment address of command line
 02A0  02AE R			fcb_5C_ofs  dw      offset fcb5C    ; Far pointers to default FCB's.  Some
 02A2  ---- R			fcb_5C_seg  dw      seg fcb5C       ;  programs (such as DOS' CHKDSK.COM)
 02A4  02BE R			fcb_6C_ofs  dw      offset fcb6C    ;  depend on these being parsed from
 02A6  ---- R			fcb_6C_seg  dw      seg fcb6C       ;  the command line before the EXEC call
				; *****************************************************************************
				
				; *****************************************************************************
				; Variables needed to parse the command line into the default FCB's
 02A8  0000			c_l_length  dw      0               ; Command line length
 02AA  0000			si_5C       dw      0               ; Save area for pointer to cmd line arg 1
 02AC  0000			si_6C       dw      0               ; Save area for pointer to cmd line arg 2
				
				; Default FCB to be passed to PSP offset 5C (hex)
 02AE				fcb5C       label   byte
 02AE  00			fcb5C_drive db      0               ; drive
 02AF  0008[			fcb5C_fname db      8 dup (?)       ; file name
	   ??			
			 ]	
				
 02B7  0003[			fcb5C_ext   db      3 dup (?)       ; extension
	   ??			
			 ]	
				
 02BA  0004[			fcb5C_pad   db      4 dup (?)       ; unused
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-5


	   ??			
			 ]	
				
				
				; Default FCB to be passed to PSP offset 6C (hex)
 02BE				fcb6C       label   byte
 02BE  00			fcb6C_drive db      0               ; drive
 02BF  0008[			fcb6C_fname db      8 dup (?)       ; file name
	   ??			
			 ]	
				
 02C7  0003[			fcb6C_ext   db      3 dup (?)       ; extension
	   ??			
			 ]	
				
 02CA  0004[			fcb6C_pad   db      4 dup (?)       ; unused
	   ??			
			 ]	
				
				; *****************************************************************************
				
 02CE  00			exec_ret    db      0               ; Return code from executed program
 02CF  00			exec_pad    db      0               ; Maintain word-alignment for variables
 02D0  0000			restore_proc dw     0               ; Address of appropriate restore routine
				
				; *****************************************************************************
				; Message to display to screen when we can't reload program
 02D2  0D 0A 53 57 41 50	abort_msg   db      0dh, 0ah, 'SWAP: Unable to reload program.', 0dh, 0ah
       3A 20 55 6E 61 62	
       6C 65 20 74 6F 20	
       72 65 6C 6F 61 64	
       20 70 72 6F 67 72	
       61 6D 2E 0D 0A		
 02F5  0023			abort_len   dw      $ - offset @code:abort_msg
				; *****************************************************************************
				
				; *****************************************************************************
				; Next, the variables needed only for certain versions of the routine,
				;  depending on which save/restore options are chosen
				; *****************************************************************************
				
				; *****************************************************************************
				; Variables needed only when swapping to XMS
				IFDEF USE_XMS
 02F7  00000000			XMS_proc    dd      0               ; Address of XMS entry point
				
 02FB				XMS_struc       label   byte        ; Structure needed to move memory with XMS
 02FB  00000000			XMS_size        dd      0           ; # of bytes to move (must be even)
 02FF  0000			XMS_from        dw      0           ; Handle of source, 0=conventional memory
 0301  00000000			XMS_from_addr   dd      0           ; Address of source memory
 0305  0000			XMS_to          dw      0           ; Handle of destionation, 0=conventional memory
 0307  00000000			XMS_to_addr     dd      0           ; Address of destination memory
				ENDIF
				; *****************************************************************************
				
				; *****************************************************************************
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-6


				; Variables needed only when swapping to EMS
				IFDEF USE_EMS
 030B  00			pages_used  db      0           ; # of pages of EMS used
 030C  45 4D 4D 58 58 58	emm_name    db      'EMMXXXX0'  ; Name of EMS device driver
       58 30			
				
 0314				EMS_struc   label   byte        ; Structure needed to move memory with EMS 4.0+
 0314  00000000			EMS_size    dd      0           ; # of bytes to move
 0318  00			EMS_from    db      0           ; Type of source memory (0 = conventional, 1 = expanded)
 0319  0000			EMS_from_h  dw      0           ; Source memory handle (0 = conventional)
 031B  0000			EMS_from_o  dw      0           ; Offset of source memory (expanded = 0-16K, conventional = 0-64K)
 031D  0000			EMS_from_s  dw      0           ; Segment/page of source (expanded = logical page, conventional = se
				gment)
 031F  00			EMS_to      db      0           ; Type of desination memory (0 = conventional, 1 = expanded)
 0320  0000			EMS_to_h    dw      0           ; Destination memory handle (0 = conventional)
 0322  0000			EMS_to_o    dw      0           ; Offset of destination memory (expanded = 0-16K, conventional = 0-6
				4K)
 0324  0000			EMS_to_s    dw      0           ; Segment/page of destination (expanded = logical page, conventional
				 = segment)
				
 0326  00000000			ems_offset  dd      0           ; Destination pointer--absolute byte offset into handle
				ENDIF
				; *****************************************************************************
				
				; *****************************************************************************
				; Variables needed only when swapping to disk
				IFDEF USE_DISK
 032A  0050[			fname       db      80 dup (0)  ; Name of the file data is saved to/read from
	   00			
			 ]	
				
 037A  0000			paras_left  dw      0           ; temporary counter
				ENDIF
				; *****************************************************************************
				
				
				
				; *****************************************************************************
				; Version-dependent code--only assemble the routine to restore the program
				; from each media (XMS, EMS, disk) if it was specified on the command line
				; *****************************************************************************
				
				
				; *****************************************************************************
				; restore_xms   Attempts to restore program from XMS extended memory
				;
				; Entry:        DS points to our variables
				;               Program was saved to XMS extended memory (block referred to by handle)
				;
				; Return:       Carry set on error, carry clear on success
				; *****************************************************************************
				IFDEF USE_XMS
 037C				restore_xms     proc    near
 037C  06			                push    es
				
				                assume  ds:@code                    ; Tell MASM that DS points to our variables
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-7


				
				; First, attempt to restore the portion of the program block that was saved
 037D  A1 000E R		xms_prog_rest:  mov     ax, wptr start_seg          ; Released segment address
 0380  8E C0			                mov     es, ax
 0382  A1 0006 R		                mov     ax, wptr prog_size          ; Size (in paragraphs)
				
 0385  33 DB			                xor     bx, bx
 0387  89 1E 0301 R		                mov     wptr XMS_from_addr, bx      ; Initialize XMS source
 038B  89 1E 0303 R		                mov     wptr XMS_from_addr + 2, bx  ;  address (offset into extended memory block)
				
 038F  E8 03C4 R		                call    rest_xms_seg                ; Attempt to restore it
				
				IFNDEF NOFRAG
 0392  72 1E			                jc      xms_dealloc                 ; Carry set = error, exit
				
				; Next, restore the extra DOS segments
 0394  8B 0E 0010 R		xms_extra_rest: mov     cx, wptr extra_count    ; Number of extra blocks to save
 0398  E3 18			                jcxz    xms_dealloc             ; If CX = 0, we exit routine
				
 039A  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of segment/size pairs
				
 039D				xms_extra_rest_loop:
 039D  8B 05			                mov     ax, wptr [di].block_seg
 039F  8E C0			                mov     es, ax                  ; ES = segment to restore
 03A1  8B 45 02			                mov     ax, wptr [di].block_size; AX = size in paragraphs
 03A4  51			                push    cx
 03A5  57			                push    di
 03A6  E8 03C4 R		                call    rest_xms_seg            ; Attempt to restore this block
 03A9  5F			                pop     di
 03AA  59			                pop     cx
 03AB  72 05			                jc      xms_dealloc             ; Carry flag set == error, exit
 03AD  83 C7 04			                add     di, size dos_block
 03B0  E2 EB			                loop    xms_extra_rest_loop     ; Keep going through all blocks
				
				ENDIF
				
 03B2  D0 D3			xms_dealloc:    rcl     bl, 1                   ; Save carry flag in low bit of bl
				
 03B4  8B 16 0052 R		                mov     dx, wptr handle         ; First, free XMS handle
 03B8  B4 0A			                mov     ah, 0Ah
 03BA  53			                push    bx
 03BB  FF 1E 02F7 R		                call    dptr XMS_proc
 03BF  5B			                pop     bx
				
 03C0  D0 DB			                rcr     bl, 1                   ; Restore carry flag from bl low bit
				
 03C2  07			restore_xms_ret:pop     es
 03C3  C3			                ret
 03C4				restore_xms     endp
				
				
				; *****************************************************************************
				; rest_xms_seg  Attempts to restore a chunk of RAM from XMS memory
				;
				; Entry:        ES points to the segment to restore
				;               AX contains its length (in paragraphs)
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-8


				;               handle holds the XMS handle to read from
				;               XMS_from_addr contains offset into extended memory for read
				;
				; Return:       Carry set on error, carry clear on success
				;               Updates XMS_from_addr for next read
				; *****************************************************************************
 03C4				rest_xms_seg    proc    near
 03C4  1E			                push    ds
 03C5  06			                push    es
				
				; Call the XMS copy memory function to do this; fill in request block
 03C6  BB 0010			xms_read_size:  mov     bx, 10h                     ; AX = # of paragraphs, convert to bytes
 03C9  F7 E3			                mul     bx                          ; DX:AX = AX * 10h, # of bytes to read
 03CB  A3 02FB R		                mov     wptr XMS_size, ax           ; Store # of bytes to read
 03CE  89 16 02FD R		                mov     wptr XMS_size + 2, dx
				
 03D2  A1 0052 R		xms_read_from:  mov     ax, wptr handle             ; Source XMS handle
 03D5  A3 02FF R		                mov     wptr XMS_from, ax           ;  XMS_from_addr already filled in
				
 03D8  33 DB			xms_read_to:    xor     bx, bx
 03DA  89 1E 0305 R		                mov     wptr XMS_to, bx             ; Read into conventional memory
 03DE  89 1E 0307 R		                mov     wptr XMS_to_addr, bx        ; Offset of dest address
 03E2  8C C0			                mov     ax, es                      ; Segment of destination address
 03E4  A3 0309 R		                mov     wptr XMS_to_addr + 2, ax
				
 03E7  BE 02FB R		do_xms_read:    mov     si, offset @code:XMS_struc  ; DS:SI -> XMS structure
 03EA  B4 0B			                mov     ah, 0Bh
 03EC  FF 1E 02F7 R		                call    dptr XMS_proc               ; Do the move
 03F0  3D 0001			                cmp     ax, 1
 03F3  75 12			                jnz     rest_xms_seg_er
				
 03F5  A1 02FB R		rest_xms_seg_ok:mov     ax, wptr XMS_size           ; Retrieve length
 03F8  8B 16 02FD R		                mov     dx, wptr XMS_size + 2       ;  (32 bits)
 03FC  01 06 0301 R		                add     wptr XMS_from_addr, ax      ; Add two 32-bit values
 0400  11 16 0303 R		                adc     wptr XMS_from_addr + 2, dx  ; Update XMS read pointer
 0404  F8			                clc                                 ; Signal success
 0405  EB 01			                jmp     short rest_xms_seg_ret
				
 0407  F9			rest_xms_seg_er:stc
				
 0408				rest_xms_seg_ret:
 0408  07			                pop     es
 0409  1F			                pop     ds
 040A  C3			                ret
 040B				rest_xms_seg    endp
				
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				; restore_ems   Attempts to restore program from EMS expanded memory
				;
				; Entry:        DS points to our variables
				;               Program was saved to EMS expanded memory (block referred to by handle)
				;
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-9


				; Return:       Carry set on error, carry clear on success
				; *****************************************************************************
				IFDEF USE_EMS
 040B				restore_ems     proc    near
 040B  06			                push    es
				
				                assume  ds:@code                    ; Tell MASM that DS points to our variables
				
				; First, attempt to restore the portion of the program block that was saved
 040C  A1 000E R		ems_prog_rest:  mov     ax, wptr start_seg          ; Released segment address
 040F  8E C0			                mov     es, ax
 0411  A1 0006 R		                mov     ax, wptr prog_size          ; Size (in paragraphs)
				
 0414  33 DB			                xor     bx, bx
 0416  89 1E 0326 R		                mov     wptr ems_offset, bx         ; Maintain absolute by offset
 041A  89 1E 0328 R		                mov     wptr ems_offset + 2, bx     ;  pointer relative to handle
				
 041E  E8 0451 R		                call    rest_ems_seg                ; Attempt to restore it
				
				IFNDEF NOFRAG
 0421  72 1E			                jc      ems_dealloc                 ; Carry set = error, exit
				
				; Next, restore the extra DOS segments
 0423  8B 0E 0010 R		ems_extra_rest: mov     cx, wptr extra_count    ; Number of extra blocks to save
 0427  E3 18			                jcxz    ems_dealloc             ; If CX = 0, we exit routine
				
 0429  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of segment/size pairs
				
 042C				ems_extra_rest_loop:
 042C  8B 05			                mov     ax, wptr [di].block_seg
 042E  8E C0			                mov     es, ax                  ; ES = segment to restore
 0430  8B 45 02			                mov     ax, wptr [di].block_size; AX = size in paragraphs
 0433  51			                push    cx
 0434  57			                push    di
 0435  E8 0451 R		                call    rest_ems_seg            ; Attempt to restore this block
 0438  5F			                pop     di
 0439  59			                pop     cx
 043A  72 05			                jc      ems_dealloc             ; Carry flag set == error, exit
 043C  83 C7 04			                add     di, size dos_block
 043F  E2 EB			                loop    ems_extra_rest_loop     ; Keep going through all blocks
				
				ENDIF
				
 0441  D0 D3			ems_dealloc:    rcl     bl, 1                   ; Save carry flag in low bit of bl
				
 0443  B4 45			                mov     ah, 45h                 ; Deallocate EMS memory
 0445  8B 16 0052 R		                mov     dx, wptr handle         ; Specify which handle
 0449  53			                push    bx
 044A  CD 67			                int     67h
 044C  5B			                pop     bx
				
 044D  D0 DB			                rcr     bl, 1                   ; Restore carry flag from bl low bit
				
 044F  07			restore_ems_ret:pop     es
 0450  C3			                ret
 0451				restore_ems     endp
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-10


				
				; *****************************************************************************
				; rest_ems_seg  Attempts to restore a chunk of RAM from EMS memory
				;
				; Entry:        ES points to the segment to restore
				;               AX contains its length (in paragraphs)
				;               handle holds the EMS handle to write to
				;               ems_offset holds the 32-bit absolute offset in expanded
				;                memory to read this block from
				;
				; Return:       Carry set on error, carry clear on success
				;               Updates ems_offset with proper offset for next read
				; *****************************************************************************
 0451				rest_ems_seg    proc    near
 0451  1E			                push    ds
 0452  06			                push    es
				
				                assume  ds:@code                ; Tell MASM DS points to our variables
				
				; Call the EMS copy memory function to do this; fill in the EMS request block
 0453  BB 0010			ems_read_size:  mov     bx, 10h                     ; AX = # of paragraphs
 0456  F7 E3			                mul     bx                          ; DX:AX = AX * 10h, convert paragraphs to bytes
 0458  A3 0314 R		                mov     wptr EMS_size, ax           ; Store # of bytes to write
 045B  89 16 0316 R		                mov     wptr EMS_size + 2, dx
				
 045F  33 DB			ems_read_to:    xor     bx, bx
 0461  88 1E 031F R		                mov     bptr EMS_to, bl             ; Copying to conventional memory (0)
 0465  89 1E 0320 R		                mov     wptr EMS_to_h, bx           ; Destination handle is 0 (conventional memory)
 0469  89 1E 0322 R		                mov     wptr EMS_to_o, bx           ; Destination offset is 0
 046D  8C C0			                mov     ax, es                      ; Segment of destination address is ES
 046F  A3 0324 R		                mov     wptr EMS_to_s, ax
				
 0472  C6 06 0318 R 01		ems_read_from:  mov     bptr EMS_from, 1            ; Copying to expanded memory
 0477  A1 0052 R		                mov     ax, wptr handle
 047A  A3 0319 R		                mov     wptr EMS_from_h, ax         ; Specify EMS handle
				
				                ; 32-bit absolute offset for copy is in ems_offset
				                ;  convert to EMS page:offset (16K pages) values
 047D  A1 0326 R		                mov     ax, wptr ems_offset         ; Load 32-byte offset
 0480  8B 16 0328 R		                mov     dx, wptr ems_offset + 2
 0484  8B D8			                mov     bx, ax                      ; Save a copy of ax (low 16 bits)
 0486  25 3FFF			                and     ax, 0011111111111111b       ; Get (ax & (16K - 1)), this is the offset (14 b
				its)
 0489  A3 031B R		                mov     wptr EMS_from_o, ax         ; Save page offset
 048C  B1 0E			                mov     cl, 14
 048E  D3 EB			                shr     bx, cl                      ; Move low 2 bits of page into low 2 bits of bx
 0490  B1 02			                mov     cl, 2
 0492  D3 E2			                shl     dx, cl                      ; Move hi ? bits of page into dx shl 2
 0494  0B D3			                or      dx, bx                      ; DX = page number (combine two values)
 0496  89 16 031D R		                mov     wptr EMS_from_s, dx         ; Save
				
 049A  A1 0314 R		                mov     ax, wptr EMS_size           ; Retrieve size of copy
 049D  8B 16 0316 R		                mov     dx, wptr EMS_size + 2
 04A1  01 06 0326 R		                add     wptr ems_offset, ax         ; Update EMS copy pointer
 04A5  11 16 0328 R		                adc     wptr ems_offset + 2, dx     ;  for next EMS write
				
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-11


 04A9  BE 0314 R		do_ems_read:    mov     si, offset @code:EMS_struc  ; DS:SI -> EMS request structure
 04AC  B8 5700			                mov     ax, 5700h                   ; Function 57 (copy/exchange memory), sub 0, cop
				y memory
 04AF  CD 67			                int     67h                         ; Call EMS manager
 04B1  0A E4			                or      ah, ah                      ; AH = 0 means success
 04B3  75 03			                jnz     rest_ems_seg_er             ; Not 0 means error
				
 04B5  F8			rest_ems_seg_ok:clc                                 ; Signal success
 04B6  EB 01			                jmp     short rest_ems_seg_ret
				
 04B8  F9			rest_ems_seg_er:stc
				
 04B9				rest_ems_seg_ret:
 04B9  07			                pop     es
 04BA  1F			                pop     ds
 04BB  C3			                ret
 04BC				rest_ems_seg    endp
				
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				; restore_disk  Attempts to restore program from DOS disk file
				;
				; Entry:        DS points to our code segment
				;               Program was saved to DOS disk file (full path stored in fname)
				;
				; Return:       Carry set on error, carry clear on success
				; *****************************************************************************
				IFDEF USE_DISK
 04BC				restore_disk    proc    near
				
 04BC  1E			                push    ds
				
				                assume  ds:@code                ; Tell MASM that DS points to our variables
				
 04BD  BA 032A R		open_file:      mov     dx, offset @code:fname  ; DS:DX -> file name
 04C0  B8 3D42			                mov     ax, 3D42h               ; DOS function 3Dh, open file
				                                                ;  al = open for read only, deny none
 04C3  CD 21			                int     21h                     ; Call DOS
 04C5  73 02			                jnc     open_ok                 ; Carry clear = all OK
 04C7  EB 3A			                jmp     short restore_disk_ret  ; Carry set, just exit with error
				
 04C9  A3 0052 R		open_ok:        mov     wptr handle, ax         ; File handle returned from DOS
				
				; First, restore the program block contents saved to disk
 04CC  A1 000E R		disk_prog_rest: mov     ax, wptr start_seg      ; Get segment of program block saved
 04CF  8E C0			                mov     es, ax
 04D1  A1 0006 R		                mov     ax, wptr prog_size      ; Get size of program block saved
 04D4  E8 0512 R		                call    rest_disk_seg           ; Try to restore it
 04D7  72 25			                jc      restore_disk_er         ; Carry set == error
				
				IFNDEF NOFRAG
				; Next, restore the contents of the extra blocks saved to disk
 04D9				disk_extra_rest:
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-12


 04D9  8B 0E 0010 R		                mov     cx, wptr extra_count    ; Number of extra blocks to restore
 04DD  E3 18			                jcxz    close_read              ; IF CX = 0, we're done restoring
				
 04DF  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of segment/size pairs
				
 04E2				disk_extra_rest_loop:
 04E2  8B 05			                mov     ax, wptr [di].block_seg
 04E4  8E C0			                mov     es, ax                  ; ES = segment to restore to
 04E6  8B 45 02			                mov     ax, wptr [di].block_size; AX = size in paragraphs
 04E9  51			                push    cx
 04EA  57			                push    di
 04EB  E8 0512 R		                call    rest_disk_seg           ; Attempt to restore this block
 04EE  5F			                pop     di
 04EF  59			                pop     cx
 04F0  72 0C			                jc      restore_disk_er         ; Error--exit routine
 04F2  83 C7 04			                add     di, size dos_block
 04F5  E2 EB			                loop    disk_extra_rest_loop    ; Look for next DOS block
				
				ENDIF
				
 04F7  B4 3E			close_read:     mov     ah, 3Eh                 ; Close file
 04F9  CD 21			                int     21h                     ; Call DOS
				
 04FB  F8			restore_disk_ok:clc                             ; Signal success
 04FC  EB 05			                jmp     short restore_disk_ret  ;  and Exit
				
 04FE				restore_disk_er:
 04FE  B4 3E			                mov     ah, 3Eh                 ; Error, close file first
 0500  CD 21			                int     21h                     ; Call DOS
 0502  F9			                stc                             ; Signal failure
				
 0503				restore_disk_ret:
 0503  1F			                pop     ds                      ; Restore our DS! (error in revs 2.11 and before)
				
 0504  D0 D3			                rcl     bl, 1                   ; Save carry flag in low bit of bl
				
 0506  BA 032A R		                mov     dx, offset @code:fname  ; DS:DX -> file name
 0509  B4 41			                mov     ah, 41h                 ; DOS function 41h, delete file
 050B  53			                push    bx
 050C  CD 21			                int     21h                     ; Call DOS
 050E  5B			                pop     bx
				
 050F  D0 DB			                rcr     bl, 1                   ; Restore carry flag from low bit of bl
				
 0511  C3			                ret
 0512				restore_disk    endp
				
				; *****************************************************************************
				; rest_disk_seg Attempts to restore a chunk of RAM from the DOS disk file
				;
				; Entry:        ES points to the segment to restore
				;               AX contains its length (in paragraphs)
				;               handle contains the file handle to read from
				;               Program was saved to DOS disk file (fname)
				;
				; Return:       Carry set on error, carry clear on success
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-13


				; *****************************************************************************
 0512				rest_disk_seg   proc    near
 0512  06			                push    es
 0513  1E			                push    ds
				
 0514  8C C3			                mov     bx, es
 0516  8E DB			                mov     ds, bx                  ; DS -> segment to restore to
				
				                assume  ds:nothing
				
 0518  2E: A3 037A R		                mov     wptr cs:paras_left, ax  ; Keep count in this variable
				
 051C  3D 0800			disk_read_32k:  cmp     ax, 0800h                   ; Less than 32K left?
 051F  72 24			                jb      last_disk_read              ; Yes, do last read
 0521  2E: 81 2E 037A R 0800	                sub     wptr cs:paras_left, 0800h   ; 32K left to read
 0528  B4 3F			                mov     ah, 3Fh                 ; DOS function 3Fh, read file
 052A  2E: 8B 1E 0052 R		                mov     bx, wptr cs:handle      ; BX = handle to read from
 052F  B9 8000			                mov     cx, 8000h               ; Read 32K bytes
 0532  33 D2			                xor     dx, dx                  ; DS:DX -> buffer to read to
 0534  CD 21			                int     21h                     ; Call DOS
 0536  72 24			                jc      rest_disk_seg_er        ; Carry set = error
				
 0538  8C D8			disk_read_ok:   mov     ax, ds                  ; Address next read location
 053A  05 0800			                add     ax, 0800h               ; It's 800h paragraphs ahead
 053D  8E D8			                mov     ds, ax                  ; DS -> new restore location
 053F  2E: A1 037A R		                mov     ax, wptr cs:paras_left  ; Expecting this above
 0543  EB D7			                jmp     short disk_read_32k     ; Read next 32K
				
 0545  B9 0004			last_disk_read: mov     cx, 4                   ; Convert paragraphs to bytes
 0548  D3 E0			                shl     ax, cl
 054A  8B C8			                mov     cx, ax                  ; # of bytes left in cx
 054C  B4 3F			                mov     ah, 3Fh                 ; Read last bytes
 054E  2E: 8B 1E 0052 R		                mov     bx, wptr cs:handle      ; BX = handle to read from
 0553  33 D2			                xor     dx, dx                  ; DS:DX -> buffer to restore to
 0555  CD 21			                int     21h                     ; Call DOS
 0557  72 03			                jc      rest_disk_seg_er        ; Error reading!  Close file first
				
 0559				rest_disk_seg_ok:
 0559  F8			                clc
 055A  EB 01			                jmp     short rest_disk_seg_ret
				
 055C				rest_disk_seg_er:
 055C  F9			                stc
				
 055D				rest_disk_seg_ret:
 055D  1F			                pop     ds
 055E  07			                pop     es
 055F  C3			                ret
 0560				rest_disk_seg   endp
				
				ENDIF
				; *****************************************************************************
				
				
				                
				; *****************************************************************************
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-14


				; execute_program   Execute the program specified
				;
				; Entry:            param_blk has been initialized
				;                   DS points to our data
				; Return:           puts return code in cs:exec_ret
				; *****************************************************************************
 0560				execute_program proc    near                    ; Called only from inside our segment
				
 0560  1E			                push    ds                      ; These are destroyed by the
 0561  06			                push    es                      ;  DOS EXEC call
				
				                assume  ds:@code                ; Tell MASM that DS points to our variables
				
 0562  8C D8			exec_program:   mov     ax, ds                  ; Our path name is in CS (point DS to our segment)
 0564  8E C0			                mov     es, ax                  ; Our parameter block is in CS (point ES to our segm
				ent)
 0566  B8 4B00			                mov     ax, 4B00h               ; Load and execute program
 0569  BB 029A R		                mov     bx, offset @code:param_blk
 056C  BA 0198 R		                mov     dx, offset @code:prog_name
 056F  CD 21			                int     21h                     ; Sets carry flag if error
				                                                ; All registers destroyed
				                                                ;  except CS:IP!
				
				                assume  ds:nothing              ; Tell MASM that DS doesn't point to our variables
				
 0571  2E: A2 02CE R		                mov     bptr cs:exec_ret, al    ; Store EXEC code
 0575  72 0A			                jc      exec_err                ; Ooops
				
 0577  B4 4D			get_return:     mov     ah, 4Dh                 ; DOS function to get ret code
 0579  CD 21			                int     21h                     ; All registers destroyed
 057B  2E: A2 02CE R		                mov     bptr cs:exec_ret, al    ; Store EXEC code
 057F  EB 07			                jmp     short exec_exit
				
 0581  2E: C7 06 0000 R 0003	exec_err:       mov     wptr cs:ret_code, 3     ; Signal error on executing
				
 0588  07			exec_exit:      pop     es
 0589  1F			                pop     ds
				
 058A  C3			                ret
				
 058B				execute_program endp
				
				
				; *****************************************************************************
				; err_exit          Prints error message and terminates program
				;
				; Entry:            Nothing.
				; Returns:          Doesn't return--calls DOS terminate function.
				;                   Naturally, we can't use the C runtime routines,
				;                   since they are swapped out.
				; *****************************************************************************
 058B				err_exit        proc    near                    ; Called only from inside our segment
				
 058B  8C C8			                mov     ax, cs
 058D  8E D8			                mov     ds, ax                  ; Point DS to our data
				
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-15


				                assume  ds:@code                ; Tell MASM that DS points to our data
				
 058F  B4 40			                mov     ah, 40h                 ; DOS function to write to file
 0591  BB 0002			                mov     bx, STDERR              ; Write to standard error handle
 0594  8B 0E 02F5 R		                mov     cx, wptr abort_len      ; CX = length of message
 0598  BA 02D2 R		                mov     dx, offset @code:abort_msg  ; DS:DX = message
 059B  CD 21			                int     21h
				
 059D  B8 4CFF			                mov     ax, 4CFFh           ; Exit, return code 255 decimal (FF hex)
 05A0  CD 21			                int     21h                 ; Exit to DOS, no return
				
 05A2				err_exit        endp
				
				
				; *****************************************************************************
				; do_exec           Calls the execute routine, then restores program
				;
				; Entry:            Nothing
				; Returns:          Since it is called from the non-resident area, it
				;                   can only return if the program is restored completely.
				; *****************************************************************************
 05A2				do_exec         proc
 05A2  E8 0560 R		                call    near ptr execute_program    ; Execute the specified program
 05A5  73 06			                jnc     re_size                     ; No carry, OK
				
 05A7  C7 06 0000 R 0003	exec_er:        mov     wptr ret_code, 3        ; Signal error
				
 05AD  8E 06 000A R		re_size:        mov     es, wptr my_psp         ; Get our PSP address
 05B1  8B 1E 0002 R		                mov     bx, wptr old_size       ; Increase back to old size
 05B5  B4 4A			                mov     ah, 4Ah                 ; DOS function 4Ah = resize
 05B7  CD 21			                int     21h
 05B9  72 23			                jc      resize_err              ; Carry clear = all OK
				
				IFNDEF NOFRAG
				; If necessary, allocate all extra DOS memory blocks our program owned
				
 05BB  8B 0E 0010 R		                mov     cx, wptr extra_count    ; CX = number of extra DOS blocks
 05BF  E3 20			                jcxz    restore_prog            ; If zero, don't bother
 05C1  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of addresses/sizes
				
 05C4  06			                push    es
				
 05C5				alloc_extra_loop:
 05C5  8B 5D 02			                mov     bx, wptr [di].block_size; BX = old size
 05C8  B4 48			                mov     ah, 48h                 ; DOS function to allocate memory block
 05CA  51			                push    cx
 05CB  57			                push    di
 05CC  CD 21			                int     21h
 05CE  5F			                pop     di
 05CF  59			                pop     cx
 05D0  72 0C			                jc      resize_err              ; Unlikely error
				
 05D2  3B 05			check_alloc:    cmp     ax, wptr [di].block_seg ; Is it the same as the origignal segment address?
 05D4  75 08			                jnz     resize_err              ; Nope.  We could do some fancy tricks here,
				                                                ;  but for the most part it's not necessary.
				
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-16


 05D6  83 C7 04			                add     di, size dos_block      ; Point to next entry
 05D9  E2 EA			                loop    alloc_extra_loop        ; Keep going through extra blocks
				
 05DB  07			                pop     es
				ENDIF
 05DC  EB 03			                jmp     short restore_prog
				
 05DE  E8 058B R		resize_err:     call    near ptr err_exit       ; Can't return, exit to DOS
				
 05E1  FF 16 02D0 R		restore_prog:   call    wptr restore_proc       ; Restore program from disk
 05E5  72 F7			                jc      resize_err              ; Carry set if error
				                                                ; If no error, it returns
				                                                ;  down to restored code
 05E7  CB			                ret
 05E8				do_exec         endp
				
				; *****************************************************************************
				; *****************************************************************************
				;ALIGN 10h		 ; Aligns next code item on paragraph boundary
				                ; para_align is a proc instead of just a data
				                ;  item because the ALIGN directive in MASM only
				                ;  applies to code items, not data items!
 05E8				para_align      proc    near
 05E8  0010[			new_mcb         db      16 dup (0)          ; DOS will put MCB of released memory here
	   00			
			 ]	
				
 05F8				para_align      endp
				; *****************************************************************************
				; *****************************************************************************
				
				; *****************************************************************************
				; Everything after here is only needed BEFORE we change our allocation size.
				;  Everything below this line will be (temporarily) swapped out of memory,
				;  and thus cannot be used once we shrink our memory allocation.
				; *****************************************************************************
				
				; *****************************************************************************
				;   swap        The routine that does it all
				;
				;   Callable by a C program, takes these parameters (regardless
				;     of which swap options chosen at assembly time, because
				;     C calling conventions let us ignore parameters to the
				;     right if we want to):
				;
				;   swap_both:
				;       prog        Full path name of program to execute
				;       cmdline     Command-line parameters for program to execute
				;       return      Pointer to byte for return code of exec'd program
				;       save_file   Full path name of file in which to save program image (if disk is to be used)
				;
				;   Depending on the memory model used, the pointers to the
				;   parameters each occupy 2 bytes or 4 bytes on the stack.
				;   If there is only one data segment (Small and Medium), each
				;   value is a 2-byte near pointer, with DS assumed as the segment
				;   register.  If there are multiple data segments (Compact and
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-17


				;   Large), each value is a 4-byte far pointer, with segment and
				;   offset values each pushed on the stack.
				;
				;   The function is declared with 4 parameters, regardless of whether
				;   disk swapping is being included.  This is because the file name
				;   parameter is the last on the parameter list, which C lets us
				;   ignore if we want.
				;
				;   The swap() routine does not check the program name or command
				;   line to verify that a legal command has been requested--that's
				;   the caller's responsibility!
				;
				; *****************************************************************************
				
								public	swap
				
 05F8				swap			 proc	 prog:PTR, cmdline:PTR, return:PTR, save_file:PTR
				
 05FB  56			                push    si                      ; Save registers needed 
 05FC  57			                push    di                      ;  by the caller
 05FD  06			                push    es
 05FE  1E			                push    ds
				
 05FF  8C C8			point_segs:     mov     ax, cs                  ; Point ES to our segment
 0601  8E C0			                mov     es, ax                  ;  for copying of parameters
				
				; *****************************************************************************
 0603				get_name:       ; Copy program name to our variable, all versions
				
				; If multiple data segments, load DS:SI from stack.  Else, just load SI
				ELSE
 0603  8B 76 06			                mov     si, wptr prog           ; Load 16-bit near pointer
				ENDIF                                           ; DS:SI -> program name from caller
				
 0606  BF 0198 R		                mov     di, offset @code:prog_name  ; ES:DI -> our storage area
				
 0609  AC			name_loop:      lodsb                           ; Fetch next byte
 060A  AA			                stosb                           ; Save next byte
 060B  0A C0			                or      al, al                  ; Was it 0 (end of string)?
 060D  75 FA			                jnz     name_loop               ; No, get next one
				
				; *****************************************************************************
				
				; *****************************************************************************
 060F				get_cmd:        ; Copy command line to our variable, all versions
				
				; If multiple data segments, load DS:SI from stack.  Else, just load SI
				ELSE
 060F  8B 76 08			                mov     si, wptr cmdline        ; Load 16-bit near pointer
				ENDIF                                           ; DS:SI -> command line from caller
				                
 0612  BF 021A R		                mov     di, offset @code:cmd_line   ; ES:DI -> our storage area
 0615  32 C9			                xor     cl, cl                  ; Keep track of length in cl
				
 0617  AC			cmd_loop:       lodsb                           ; Fetch next byte from DS:SI
 0618  0A C0			                or      al, al                  ; Was it 0 (end of string)?
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-18


 061A  74 08			                jz      cmd_end                 ; Yes, we're done
 061C  AA			                stosb                           ; No, store byte
 061D  FE C1			                inc     cl                      ; Increment length
 061F  80 F9 7F			                cmp     cl, MAX_DOS_CMD         ; Are we at maximum cmd length?
 0622  75 F3			                jnz     cmd_loop                ; Nope, keep going
				
 0624  26: C6 05 0D		cmd_end:        mov     bptr es:[di], 0dh       ; Put CR at end of cmd line
 0628  2E: 88 0E 0219 R		                mov     bptr cs:cmd_len, cl     ; Store command-line length
				
				; *****************************************************************************
				; Set up the default FCBs at 5Ch and 6Ch in the PSP
				;  Code provided by David E. Jenkins
 062D  1E			                push    ds                      ; Save caller's DS
				
 062E  8C C8			                mov     ax, cs                  ; Point DS to our
 0630  8E D8			                mov     ds, ax                  ;  variables
				
				                assume  ds:@code                ; Tell MASM that DS points to our variables
				;
				;   Locate the first two command line arguments
				;
 0632  1E			                push    ds                      ; Copy ds into es
 0633  07			                pop     es                      ;  "   "   "   "
 0634  BF 021A R		                mov     di, offset @code:cmd_line   ; Point to command line in CS
 0637  A0 0219 R		                mov     al, bptr cmd_len            ; load the command line length
 063A  32 E4			                xor     ah, ah
 063C  40			                inc     ax                      ; Include the CR in the length
 063D  A3 02A8 R		                mov     wptr c_l_length, ax     ; Save the command line length
 0640  03 C7			                add     ax, di                  ; Point to end of command line
 0642  A3 02AA R		                mov     wptr si_5c, ax          ; default to just after command line
 0645  A3 02AC R		                mov     wptr si_6c, ax          ;    "    "   "     "      "     "
 0648  80 3E 0219 R 00		                cmp     bptr cmd_len, 0         ; Is there anything to parse?
 064D  74 26			                jz      args_located            ; if not then args have been located
				
 064F  8B 0E 02A8 R		                mov     cx, wptr c_l_length     ; Load the command line length
 0653  B0 20			                mov     al, ' '                 ; We must find the first non-blank
 0655  F3/ AE			                repe    scasb                   ; Go until we find it or run out
 0657  0B C9			                or      cx, cx                  ; Did we run out (CX = 0)?
 0659  74 1A			                jz      args_located            ; Yes--then args have been located
				
 065B  4F			                dec     di                      ; Move back to the right one
 065C  41			                inc     cx                      ;  "    "   "   "    "    "
 065D  89 3E 02AA R		                mov     wptr si_5c, di          ; Save the location of arg 1
 0661  F2/ AE			                repne   scasb                   ; Find the next space (between arg1,2)
 0663  0B C9			                or      cx, cx                  ; Did we run out
 0665  74 0E			                jz      args_located            ; If so then args have been located
				
 0667  4F			                dec     di                      ; Move back to the left one
 0668  41			                inc     cx                      ;  "    "   "   "    "   "
 0669  F3/ AE			                repe    scasb                   ; Now find next non-blank (arg 2)
 066B  0B C9			                or      cx, cx                  ; Did we run out
 066D  74 06			                jz      args_located            ; If so then args have been located
				
 066F  4F			                dec     di                      ; Move back to the right one
 0670  41			                inc     cx                      ;  "    "   "   "    "    "
 0671  89 3E 02AC R		                mov     wptr si_6c,di           ; Save location of arg 2
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-19


				
 0675				args_located:
				; parse the first argument into the first FCB
				
 0675  8B 36 02AA R		                mov     si, wptr si_5c                  ; Point to the first argument
 0679  BF 02AE R		                mov     di, offset @code:fcb5C_drive    ; Point to the unopened FCB
 067C  B4 29			                mov     ah, 29h                 ; Parse file name function
 067E  B0 00			                mov     al, 00h                 ; Do it like COMMAND.COM does it
 0680  CD 21			                int     21h                     ; go for it
				
				; parse the second argument into the second FCB
 0682  8B 36 02AC R		                mov     si, wptr si_6c                  ; Point to the second argument
 0686  BF 02BE R		                mov     di, offset @code:fcb6c_drive    ; point to the unopened FCB
 0689  B4 29			                mov     ah, 29h                 ; Parse file name function
 068B  B0 00			                mov     al, 00h                 ; Do it like COMMAND.COM does it
 068D  CD 21			                int     21h                     ; go for it
				
 068F  1F			                pop     ds                      ; Restore caller's DS
				
				; *****************************************************************************
				; Get the file name from the command line, if this version needs it
				IFDEF USE_DISK
 0690				get_file:
				
				; If multiple data segments, load DS:SI, else just load SI
				ELSE
 0690  8B 76 0C			                mov     si, save_file           ; Load 16-bit pointer
				ENDIF                                           ; DS:SI -> swap file name from caller
				
 0693  BF 032A R		                mov     di, offset @code:fname  ; ES:DI -> our storage area
				
 0696  B4 60			resolve:        mov     ah, 60h                 ; DOS INTERNAL function to resolve file name to full
				 path name
 0698  CD 21			                int     21h                     ; Stores complete path at ES:DI--we need it after EX
				EC in case
				                                                ;  current drive or directory have changed
				                                                ; Ignore file name error here--it
				                                                ;  will be caught in save_disk if need be
				
				
				ENDIF           ; IFDEF disk
				; *****************************************************************************
				; We have the parameters--let's go
				; *****************************************************************************
				
 069A  2E: C7 06 0000 R 0000	                mov     wptr cs:ret_code, 0     ; Initialize swap's return code
 06A1  2E: C6 06 02CE R 00	                mov     cs:exec_ret, 0          ; Initialize exec's return code
				
 06A7  8C D0			save_stack:     mov     ax, ss
 06A9  2E: A3 0056 R		                mov     wptr cs:old_ss, ax      ; Save current SS
 06AD  8B C4			                mov     ax, sp
 06AF  2E: A3 0054 R		                mov     wptr cs:old_sp, ax      ; Save current SP
				
 06B3  8C C8			our_stack:      mov     ax, cs                  ; Our stack is in our CS
 06B5  FA			                cli                             ; Disable interrupts
 06B6  8E D0			                mov     ss, ax
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-20


 06B8  BC 0198 R		                mov     sp, offset @code:new_sp ; Set new stack
 06BB  FB			                sti                             ; Re-enable interrupts
				
 06BC  06			save_regs:      push    es                      ; Save needed registers
 06BD  1E			                push    ds                      ; This is the caller's DS!
 06BE  55			                push    bp
				
 06BF  8C C8			                mov     ax, cs
 06C1  8E D8			                mov     ds, ax                  ; Point DS to our data
				
				                assume  ds:@code                ; Tell MASM that DS points to our variables
				
 06C3  B4 51			save_info:      mov     ah, 51h                 ; DOS function 51h, get PSP
 06C5  CD 21			                int     21h                     ; Call DOS
 06C7  8B C3			                mov     ax, bx                  ; ax = PSP
 06C9  A3 000A R		                mov     wptr my_psp, ax         ; Save in cs: addressable location
 06CC  48			                dec     ax                      ; PSP-1 = MCB for this mem block
 06CD  8E C0			                mov     es, ax
 06CF  26: A1 0001		                mov     ax, es:[0001h]          ; Get PSP address--should be same!
 06D3  3B 06 000A R		                cmp     ax, wptr my_psp         ; All kosher?
 06D7  74 08			                jz      psp_ok                  ; Yes
				
 06D9  C7 06 0000 R 0001	psp_error:      mov     wptr ret_code, 1        ; No, pass return code
 06DF  EB 4B			                jmp     short exit_swap         ; Exit
				
 06E1  E8 074F R		psp_ok:         call    near ptr calc_size      ; Calc size to keep, save
				
 06E4  E8 081B R		try_save:       call    near ptr save_program   ; Write program to disk
 06E7  73 08			                jnc     shrink_mem              ; Carry flag set on error
				
 06E9  C7 06 0000 R 0002	no_save:        mov     wptr ret_code, 2        ; Error--set return code
 06EF  EB 3B			                jmp     short exit_swap         ; Exit routine on error
				
 06F1  B4 4A			shrink_mem:     mov     ah, 4Ah                 ; DOS 4Ah--modify memory allocation
 06F3  8E 06 000A R		                mov     es, wptr my_psp         ; Point to PSP again
 06F7  8B 1E 0004 R		                mov     bx, wptr new_size       ; new_size was figured in calc_size
 06FB  CD 21			                int     21h                     ; Call DOS to shrink size
 06FD  72 20			                jc      no_shrink               ; Carry set = error
				
				IFNDEF NOFRAG
				; If necessary, free all extra DOS memory blocks our program owns
				
 06FF  8B 0E 0010 R		                mov     cx, wptr extra_count    ; CX = number of extra DOS blocks
 0703  E3 22			                jcxz    exec_prog               ; If zero, don't bother
 0705  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of addresses/sizes
				
 0708  06			                push    es
				
 0709				free_extra_loop:
 0709  8B 05			                mov     ax, wptr [di].block_seg
 070B  8E C0			                mov     es, ax                  ; ES = DOS memory segment to free
 070D  B4 49			                mov     ah, 49h                 ; DOS function to free memory block
 070F  51			                push    cx
 0710  57			                push    di
 0711  CD 21			                int     21h
 0713  5F			                pop     di
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-21


 0714  59			                pop     cx
 0715  72 08			                jc      no_shrink               ; Unlikely error
 0717  83 C7 04			                add     di, size dos_block      ; Point to next entry
 071A  E2 ED			                loop    free_extra_loop         ; Keep going through extra blocks
				
 071C  07			                pop     es
				ENDIF
				
 071D  EB 08			                jmp     short exec_prog
				
				; *****************************************************************************
				; Any routine called or data referred to after this point MUST be located
				;  in this source file BEFORE the variable new_mcb below!
				; *****************************************************************************
				
 071F  C7 06 0000 R 0001	no_shrink:      mov     wptr ret_code, 1        ; Carry = couldn't shrink block
 0725  EB 05			                jmp     short exit_swap         ; Should delete file here!
				
 0727  9A 05A2 ---- R		exec_prog:      call    do_exec                 ; This code is resident, and can
				                                                ;  be found above the resident line
				
				; do_exec execute the routine AND restores the program!
				
 072C  5D			exit_swap:      pop     bp                      ; Restore saved registers
 072D  1F			                pop     ds                      ; This is the caller's DS!
 072E  07			                pop     es
				
				                assume  ds:nothing              ; Tell MASM DS doesn't point to our variables
				
 072F  2E: A1 0056 R		prev_stack:     mov     ax, wptr cs:old_ss      ; Restore original stack
 0733  FA			                cli
 0734  8E D0			                mov     ss, ax
 0736  2E: 8B 26 0054 R		                mov     sp, wptr cs:old_sp
 073B  FB			                sti
				
				; Giving user exec's return code.  It could be a 16- or 32-bit pointer
				ELSE
 073C  8B 76 0A			                mov     si, wptr return         ; Load 16-bit pointer
				ENDIF                                           ; DS:SI -> return code variable
				                
 073F  2E: A0 02CE R		                mov     al, bptr cs:exec_ret    ; Store exec's return code
 0743  88 04			                mov     bptr [si], al           ;  at address specified by caller
				
				
 0745  1F			                pop     ds
 0746  07			                pop     es
 0747  5F			                pop     di
 0748  5E			                pop     si
 0749  2E: A1 0000 R		                mov     ax, wptr cs:ret_code    ; Give return code
 074E  CB			                ret
 074F				swap			 endp
				
				; *****************************************************************************
				; *****************************************************************************
				; calc_size     Calculates the total size (in paragraphs) of all DOS blocks
				;               owned by this program plus the amount of the initial program
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-22


				;               allocation block we can swap out.
				;
				; Entry:        DS points to our variables
				;               ES points to DOS Memory Control Block for our program
				;
				; Return:       old_size, start_seg, new_size, total_paras, extra_count initialized
				; *****************************************************************************
 074F				calc_size       proc    near                    ; Called only from inside our segment
				
 074F  06			                push    es
				
				                assume  ds:@code                ; Tell MASM that DS points to our variables
				
 0750  26: A1 0003		                mov     ax, es:[0003h]          ; Get # paragraphs allocated
				                                                ;  in this memory block
 0754  A3 0002 R		                mov     wptr old_size, ax       ; Save old size of program
 0757  8C CB			                mov     bx, cs                  ; BX = segment of our code
 0759  B8 05E8 R		                mov     ax, offset @code:new_mcb; Last address to keep
 075C  B1 04			                mov     cl, 4                   ; new_mcb is para aligned
 075E  D3 E8			                shr     ax, cl                  ; AX = ofs new_mcb / 16
 0760  40			                inc     ax
 0761  03 D8			                add     bx, ax
 0763  89 1E 000E R		                mov     wptr start_seg, bx      ; Segment of released memory
 0767  2B 1E 000A R		                sub     bx, wptr my_psp         ; BX = size to keep in paragraphs
 076B  89 1E 0004 R		                mov     wptr new_size, bx       ; Save new, smaller size
 076F  A1 0002 R		                mov     ax, wptr old_size
 0772  2B C3			                sub     ax, bx
 0774  A3 0006 R		                mov     wptr prog_size, ax      ; ax = size of program block to swap out
 0777  A3 0008 R		                mov     wptr total_paras, ax    ; ax = total paragraphs
				
				IFNDEF NOFRAG
				; Now loop through all subsequent MCBs looking for blocks that we own (if
				;  the MCB's "owner" (PSP) matches us (our PSP).  Right now ES points to
				;  our MCB.  The MCB has three fields of interest:
				;
				;   Offset  Size    Description
				;   -------------------------------------------------------------------------
				;   0000h   Byte    Chain flag: 'M' (4Dh) if not last, 'Z' (5Ah) if last block in chain
				;   0001h   Word    PSP segment of owner, 0000h if free memory
				;   0003h   Word    Size of memory block in paragraphs, NOT including this MCB!
				
 077A  C7 06 0010 R 0000	find_extras:    mov     wptr extra_count, 0     ; Initialize count
 0780  8B 1E 000A R		                mov     bx, wptr my_psp         ; Use bx to hold PSP for easy comparisons
 0784  BF 0012 R		                mov     di, offset dos_blocks   ; di = pointer to storage area
				
 0787  26: 80 3E 0000 5A	check_next_mcb: cmp     bptr es:[0000h], 'Z'    ; Is this the last block?
 078D  74 32			                jz      calc_size_ret           ; Yup
				
 078F  8C C0			next_mcb2:      mov     ax, es                  ; ax = this MCB
 0791  26: 8B 0E 0003		                mov     cx, wptr es:[0003h]     ; cx = size of this mcb
 0796  03 C1			                add     ax, cx
 0798  40			                inc     ax                      ; ax = addres of next MCB
 0799  8E C0			                mov     es, ax                  ; ES -> next MCB
				
 079B  26: 39 1E 0001		my_block:       cmp     wptr es:[0001h], bx     ; Does it match my PSP?
 07A0  75 E5			                jnz     check_next_mcb          ; Nope, move along
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-23


				
 07A2  FF 06 0010 R		is_my_block:    inc     wptr extra_count        ; One more extra block
 07A6  83 3E 0010 R 10		                cmp     wptr extra_count, MAX_EXTRA
 07AB  77 14			                ja      calc_size_ret           ; Too many blocks--just exit
				
 07AD  40			is_my_block2:   inc     ax                      ; Was MCB, now is address of segment
 07AE  89 05			                mov     wptr [di].block_seg, ax ; Store segment address
 07B0  26: 8B 0E 0003		                mov     cx, wptr es:[0003h]     ; Get size in paragraphs
 07B5  89 4D 02			                mov     wptr [di].block_size, cx; Store size
 07B8  01 0E 0008 R		                add     wptr total_paras, cx    ; Increment total
 07BC  83 C7 04			                add     di, size dos_block      ; Next index (move pointer)
 07BF  EB C6			                jmp     short check_next_mcb
				ENDIF
				
 07C1  07			calc_size_ret:  pop     es
 07C2  C3			                ret
				
 07C3				calc_size       endp
				; *****************************************************************************
				
				; *****************************************************************************
				; xms_installed     Checks to see if XMS driver (himem.sys) is loaded
				;
				; Entry:            No assumptions--can be called by user
				; Return:           1 if XMS driver is load, 0 if not
				; *****************************************************************************
				IFDEF USE_XMS
								public	xms_installed
 07C3				xms_installed	 proc							 ; Called by user also!
				
 07C3  1E			                push    ds                  ; Save all "important" registers
 07C4  56			                push    si
 07C5  06			                push    es
 07C6  57			                push    di
				
 07C7  B8 4300			                mov     ax, 4300h           ; Multiplex code for XMS driver, load check function
 07CA  CD 2F			                int     2Fh                 ; Call multiplex interrupt
 07CC  3C 80			                cmp     al, 80h             ; al = 80h means XMS driver IS loaded
 07CE  75 14			                jnz     no_xms              ; Nope, not there
				
 07D0  B8 4310			yes_xms:        mov     ax, 4310h               ; Get address of entry point
 07D3  CD 2F			                int     2Fh                     ; Returns address in ES:BX
 07D5  2E: 89 1E 02F7 R		                mov     wptr cs:XMS_proc, bx
 07DA  2E: 8C 06 02F9 R		                mov     wptr cs:XMS_proc + 2, es
 07DF  B8 0001			                mov     ax, 1                   ; Return 1, XMS installed
 07E2  EB 02			                jmp     short xms_ret
				
 07E4  33 C0			no_xms:         xor     ax, ax              ; Return 0, XMS not installed
				
 07E6  5F			xms_ret:        pop     di
 07E7  07			                pop     es
 07E8  5E			                pop     si
 07E9  1F			                pop     ds
 07EA  CB			                ret
				
 07EB				xms_installed	 endp
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-24


				ENDIF
				; *****************************************************************************
				
				; *****************************************************************************
				; ems4_installed    Checks to see if EMS 4.0 or above driver is loaded
				;
				; Entry:            No assumptions--can be called by user
				; Return:           1 if EMS 4.0 driver is load, 0 if not
				; *****************************************************************************
				IFDEF USE_EMS
								public	ems4_installed
 07EB				ems4_installed	proc							 ; Called by user also!
				
 07EB  1E			                push    ds                      ; Save "important" registers
 07EC  56			                push    si
 07ED  06			                push    es
 07EE  57			                push    di
				
				
 07EF  B4 35			get_emm_vector: mov     ah, GET_VECTOR          ; Get EMM interrupt vector
 07F1  B0 67			                mov     al, 67h                 ; EMM accessed through Int 67h
 07F3  CD 21			                int     21h                     ; Call DOS to get vector
 07F5  BF 000A			                mov     di, 0ah                 ; vector + di = name
 07F8  8C C8			                mov     ax, cs
 07FA  8E D8			                mov     ds, ax                  ; DS:SI -> EMM device driver name
 07FC  BE 030C R		                mov     si, offset @code:emm_name   ; Compare with EMM device name
 07FF  B9 0008			                mov     cx, EMM_NAME_LEN
 0802  FC			                cld
 0803  F3/ A6			                repe    cmpsb                   ; Compare bytes
 0805  75 0D			                jnz     ems_no                  ; Same?  If not, EMS installed
				
 0807  B4 46			ems_yes:        mov     ah, 46h                 ; Get EMM version number
 0809  CD 67			                int     67h                     ; Returns BCD in al
 080B  3C 40			                cmp     al, 40h                 ; Look only at high 4 bits
 080D  72 05			                jb      ems_no                  ; Version not high enough--return 0
				
 080F  B8 0001			ems4_yes:       mov     ax, 1                   ; EMS installed, return 1
 0812  EB 02			                jmp     short ems_ret
				
 0814  33 C0			ems_no:         xor     ax, ax                  ; EMS not installed, return 0
				
 0816  5F			ems_ret:        pop     di
 0817  07			                pop     es
 0818  5E			                pop     si
 0819  1F			                pop     ds
 081A  CB			                ret
				
 081B				ems4_installed	endp
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				; save_program      Try to save in XMS/EMS/disk.
				;
				; Entry:            DS points to our variables
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-25


				;
				; Returns:          Success:  carry flag clear
				;                   Failure:  carry flag set
				; *****************************************************************************
 081B				save_program    proc    near            ; Called only from inside our segment
				
 081B  56			                push    si              ; Save registers
 081C  57			                push    di
 081D  1E			                push    ds
 081E  06			                push    es
				
				; Now figure out which routines to call, based on command-line definitions
				; To change the order in which swap() attempts to swap, change the order
				;  of these three conditional blocks.
				   
				
				; *****************************************************************************
				IFDEF USE_XMS
 081F  E8 0837 R		                call    save_xms        ; Try saving to XMS extended memory
 0822  73 0D			                jnc     save_ok         ; Carry clear == success, all done
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				IFDEF USE_EMS
 0824  E8 08ED R		                call    save_ems        ; Try saving to EMS expanded memory
 0827  73 08			                jnc     save_ok       ; Carry clear == success, all done
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				IFDEF USE_DISK
 0829  E8 09C8 R		                call    save_disk       ; Try saving to DOS disk file
 082C  73 03			                jnc     save_ok         ; Carry clear == success, all done
				ENDIF
				; *****************************************************************************
				
 082E  F9			save_er:        stc                     ; Couldn't save anywhere, return error
 082F  EB 01			                jmp     short save_ret
				
 0831  F8			save_ok:        clc                     ; Saved successfully, return OK
				
 0832  07			save_ret:       pop     es              ; Restore registers
 0833  1F			                pop     ds
 0834  5F			                pop     di
 0835  5E			                pop     si
				
 0836  C3			                ret
 0837				save_program    endp
				; *****************************************************************************
				
				
				; *****************************************************************************
				; Version-dependent code--only assemble the routine to save the program
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-26


				; to each place if it was requested on the command line
				; *****************************************************************************
				
				
				; *****************************************************************************
				; save_xms      Attempts to save program to XMS extended memory
				;
				; Entry:        DS points to our variables
				;
				; Return:       Carry set on error, carry clear on success
				;               If successful, updates restore_proc with the address of
				;               the XMS restore routine
				; *****************************************************************************
				IFDEF USE_XMS
 0837				save_xms        proc    near
				
				                assume  ds:@code                ; Tell MASM DS points to our variables
				
 0837  9A 07C3 ---- R						call	xms_installed			 ; Check if XMS installed
 083C  0B C0			                or      ax, ax                  ; Returns 0 if not installed
 083E  75 02			                jnz     xms_inst                ; AX != 0, XMS installed
 0840  EB 59			                jmp     short save_xms_er       ; AX == 0, XMS not installed
				
 0842  8B 16 0008 R		xms_inst:       mov     dx, wptr total_paras    ; dx = total # of paragraphs to write
 0846  B1 06			                mov     cl, 6                   ; Convert Paragraphs to kilobytes
 0848  D3 EA			                shr     dx, cl                  ; dx = dx / 64
 084A  42			                inc     dx                      ; dx = kilobytes needed (plus 1 for safety)
				
 084B  B4 09			xms_alloc:      mov     ah, 09h                 ; XMS function 09, allocate extended memory block
 084D  FF 1E 02F7 R		                call    dptr XMS_proc           ; Call XMS entry point directly
 0851  3D 0001			                cmp     ax, 1                   ; AX = 1 on success
 0854  75 45			                jnz     save_xms_er             ; Allocation unsuccessful, error
				
 0856  89 16 0052 R		xms_alloc_ok:   mov     wptr handle, dx         ; Save returned handle in DX
				
				; First, attempt to save the portion of the program block
 085A  A1 000E R		xms_prog_save:  mov     ax, wptr start_seg      ; Released segment address
 085D  8E C0			                mov     es, ax
 085F  A1 0006 R		                mov     ax, wptr prog_size      ; Size (in paragraphs) of program block to save
 0862  33 DB			                xor     bx, bx
 0864  89 1E 0307 R		                mov     wptr XMS_to_addr, bx    ; Initialize XMS destination
 0868  89 1E 0309 R		                mov     wptr XMS_to_addr + 2, bx;  address (offset into extended memory block)
				
 086C  E8 08A6 R		                call    save_xms_seg            ; Attempt to save the program block
 086F  72 20			                jc      write_error             ; Carry set = failure, return
				
				IFNDEF NOFRAG
				; Next, save the extra DOS segments
 0871  8B 0E 0010 R		xms_extra_save: mov     cx, wptr extra_count    ; Number of extra blocks to save
 0875  E3 27			                jcxz    save_xms_ok             ; If CX = 0, we exit routine
				
 0877  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of segment/size pairs
				
 087A				xms_extra_save_loop:
 087A  8B 05			                mov     ax, wptr [di].block_seg
 087C  8E C0			                mov     es, ax                  ; ES = segment to save
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-27


 087E  8B 45 02			                mov     ax, wptr [di].block_size; AX = size in paragraphs
 0881  51			                push    cx
 0882  57			                push    di
 0883  E8 08A6 R		                call    save_xms_seg            ; Attempt to save this block
 0886  5F			                pop     di
 0887  59			                pop     cx
 0888  72 07			                jc      write_error             ; Carry flag set == error
 088A  83 C7 04			                add     di, size dos_block
 088D  E2 EB			                loop    xms_extra_save_loop     ; Keep going through all blocks
				
				ENDIF
 088F  EB 0D			                jmp     short save_xms_ok
				
 0891  8B 16 0052 R		write_error:    mov     dx, wptr handle             ; Free allocated handle
 0895  B4 0A			                mov     ah, 0Ah
 0897  FF 1E 02F7 R		                call    dptr XMS_proc               ; Falls through to failure code
				
 089B  F9			save_xms_er:    stc
 089C  EB 07			                jmp     short save_xms_ret
				
 089E  C7 06 02D0 R 037C R	save_xms_ok:    mov     wptr restore_proc, offset @code:restore_xms     ; Initialize pointer
 08A4  F8			                clc                                                     ;  to restore routine
				
 08A5  C3			save_xms_ret:   ret
 08A6				save_xms        endp
				
				
				; *****************************************************************************
				; save_xms_seg  Attempts to save a chunk of RAM to XMS memory
				;
				; Entry:        ES points to the segment to save
				;               AX contains its length (in paragraphs)
				;               handle holds the XMS handle to write to
				;               XMS_to_addr contains offset into extended memory for write
				;
				; Return:       Carry set on error, carry clear on success
				;               Updates XMS_to_addr for next write
				; *****************************************************************************
 08A6				save_xms_seg    proc    near
 08A6  1E			                push    ds
 08A7  06			                push    es
				
				; Call the XMS copy memory function to do this; fill in the XMS request block
 08A8  BB 0010			xms_write_size: mov     bx, 10h                     ; AX = # of paragraphs
 08AB  F7 E3			                mul     bx                          ; DX:AX = AX * 10h, convert paragraphs to bytes
 08AD  A3 02FB R		                mov     wptr XMS_size, ax           ; Store # of bytes to write
 08B0  89 16 02FD R		                mov     wptr XMS_size + 2, dx
				
 08B4  33 DB			xms_write_from: xor     bx, bx
 08B6  89 1E 02FF R		                mov     wptr XMS_from, bx           ; 0 means from conventional memory
 08BA  89 1E 0301 R		                mov     wptr XMS_from_addr, bx      ; Offset of source address is 0
 08BE  8C C0			                mov     ax, es                      ; Segment of source address is ES
 08C0  A3 0303 R		                mov     wptr XMS_from_addr + 2, ax
				
 08C3  A1 0052 R		xms_write_to:   mov     ax, wptr handle             ; Destination XMS handle
 08C6  A3 0305 R		                mov     wptr XMS_to, ax             ;  XMS_to_addr already filled in
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-28


				
 08C9  BE 02FB R		do_xms_write:   mov     si, offset @code:XMS_struc  ; DS:SI -> XMS request structure
 08CC  B4 0B			                mov     ah, 0Bh                     ; Function B, copy memory
 08CE  FF 1E 02F7 R		                call    dptr XMS_proc               ; Do the memory copy move
 08D2  3D 0001			                cmp     ax, 1                       ; AX = 1 means success
 08D5  75 12			                jnz     save_xms_seg_er             ; Success, all done!
				
 08D7  A1 02FB R		save_xms_seg_ok:mov     ax, wptr XMS_size           ; Retrieve length
 08DA  8B 16 02FD R		                mov     dx, wptr XMS_size + 2       ;  (32 bits)
 08DE  01 06 0307 R		                add     wptr XMS_to_addr, ax        ; Add two 32-bit values
 08E2  11 16 0309 R		                adc     wptr XMS_to_addr + 2, dx    ; Update XMS write pointer
 08E6  F8			                clc                                 ; Signal success
 08E7  EB 01			                jmp     short save_xms_seg_ret
				
 08E9  F9			save_xms_seg_er:stc
				
 08EA				save_xms_seg_ret:
 08EA  07			                pop     es
 08EB  1F			                pop     ds
 08EC  C3			                ret
 08ED				save_xms_seg    endp
				
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				; save_ems      Attempts to save program to EMS 4.0 expanded memory
				;
				; Entry:        DS points to our variables
				;
				; Return:       Carry set on error, carry clear on success
				;               If successful, updates restore_proc with the address of
				;               the EMS restore routine
				; *****************************************************************************
				IFDEF USE_EMS
 08ED				save_ems        proc    near
				
				                assume  ds:@code                ; Tell MASM DS points to our variables
				
 08ED  9A 07EB ---- R						call	ems4_installed		 ; Check if EMS 4.0 installed
 08F2  0B C0			                or      ax, ax                  ; AX = 0 if not installed
 08F4  75 02			                jnz     ems_inst                ; AX != 0, ems installed
 08F6  EB 63			                jmp     short save_ems_er       ; AX = 0, no EMS, error!
				
 08F8  8B 1E 0008 R		ems_inst:       mov     bx, wptr total_paras    ; Total # of paragraphs we need
 08FC  B1 0A			                mov     cl, 10                  ; Convert Paragraphs to 16K pages
 08FE  D3 EB			                shr     bx, cl
 0900  43			                inc     bx                      ; BX = pages needed
 0901  88 1E 030B R		                mov     bptr pages_used, bl     ; Save for later use
				
 0905  B4 43			                mov     ah, 43h                 ; EMM function 43h, allocate
 0907  CD 67			                int     67h
 0909  0A E4			                or      ah, ah                  ; OK return code?
 090B  74 02			                jz      ems_alloc_ok            ; Yes, skip ahead
 090D  EB 4C			                jmp     short save_ems_er       ; No, not enough EMS
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-29


				
 090F  89 16 0052 R		ems_alloc_ok:   mov     wptr handle, dx         ; Returned handle in DX
				
				; First, attempt to save the portion of the program block
 0913  A1 000E R		ems_prog_save:  mov     ax, wptr start_seg      ; Released segment address
 0916  8E C0			                mov     es, ax
 0918  A1 0006 R		                mov     ax, wptr prog_size      ; Size (in paragraphs) of program block to save
				
 091B  33 DB			                xor     bx, bx
 091D  89 1E 0326 R		                mov     wptr ems_offset, bx     ; Maintain absolute byte offset
 0921  89 1E 0328 R		                mov     wptr ems_offset + 2, bx ;  pointer into handle
				
 0925  E8 095D R		                call    save_ems_seg            ; Attempt to save the program block
				
 0928  72 20			                jc      save_ems_fail           ; Carry set = failure, return
				
				IFNDEF NOFRAG
				; Next, save the extra DOS segments
 092A  8B 0E 0010 R		ems_extra_save: mov     cx, wptr extra_count    ; Number of extra blocks to save
 092E  E3 22			                jcxz    save_ems_ok             ; If CX = 0, we exit routine
				
 0930  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of segment/size pairs
				
 0933				ems_extra_save_loop:
 0933  8B 05			                mov     ax, wptr [di].block_seg
 0935  8E C0			                mov     es, ax                  ; ES = segment to save
 0937  8B 45 02			                mov     ax, wptr [di].block_size; AX = size in paragraphs
 093A  51			                push    cx
 093B  57			                push    di
 093C  E8 095D R		                call    save_ems_seg            ; Attempt to save this block
 093F  5F			                pop     di
 0940  59			                pop     cx
 0941  72 07			                jc      save_ems_fail           ; Carry flag set == error
 0943  83 C7 04			                add     di, size dos_block
 0946  E2 EB			                loop    ems_extra_save_loop     ; Keep going through all blocks
				ENDIF
 0948  EB 08			                jmp     short save_ems_ok
				
 094A  8B 16 0052 R		save_ems_fail:  mov     dx, wptr handle         ; Failure--free handle
 094E  B4 45			                mov     ah, 45h
 0950  CD 67			                int     67h                     ; Falls through to failure code
				
 0952  C7 06 02D0 R 040B R	save_ems_ok:    mov     wptr restore_proc, offset @code:restore_ems     ; Initialize pointer
 0958  F8			                clc                                                     ;  to restore routine
 0959  EB 01			                jmp     short save_ems_ret
				
 095B  F9			save_ems_er:    stc
				
 095C  C3			save_ems_ret:   ret
 095D				save_ems        endp
				
				; *****************************************************************************
				; save_ems_seg  Attempts to save a chunk of RAM to EMS memory
				;
				; Entry:        ES points to the segment to save
				;               AX contains its length (in paragraphs)
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-30


				;               handle holds the EMS handle to write to
				;               ems_offset holds the 32-bit absolute offset in expanded
				;                memory to write this block to
				;
				; Return:       Carry set on error, carry clear on success
				;               Updates ems_offset with proper offset for next write
				; *****************************************************************************
 095D				save_ems_seg    proc    near
 095D  1E			                push    ds
 095E  06			                push    es
				
				                assume  ds:@code                ; Tell MASM DS points to our variables
				
				; Call the EMS copy memory function to do this; fill in the eMS request block
 095F  BB 0010			ems_write_size: mov     bx, 10h                     ; AX = # of paragraphs
 0962  F7 E3			                mul     bx                          ; DX:AX = AX * 10h, convert paragraphs to bytes
 0964  A3 0314 R		                mov     wptr EMS_size, ax           ; Store # of bytes to write
 0967  89 16 0316 R		                mov     wptr EMS_size + 2, dx
				
 096B  33 DB			ems_write_from: xor     bx, bx
 096D  88 1E 0318 R		                mov     bptr EMS_from, bl           ; Copying from conventional memory (0)
 0971  89 1E 0319 R		                mov     wptr EMS_from_h, bx         ; Source handle is 0 (conventional memory)
 0975  89 1E 031B R		                mov     wptr EMS_from_o, bx         ; Source offset is 0
 0979  8C C0			                mov     ax, es                      ; Segment of source address is ES
 097B  A3 031D R		                mov     wptr EMS_from_s, ax
				
 097E  C6 06 031F R 01		ems_write_to:   mov     bptr EMS_to, 1              ; Copying to expanded memory
 0983  A1 0052 R		                mov     ax, wptr handle
 0986  A3 0320 R		                mov     wptr EMS_to_h, ax           ; Specify EMS handle
				
				                ; 32-bit absolute offset for copy is in ems_offset
				                ;  convert to EMS page:offset (16K pages) values
 0989  A1 0326 R		                mov     ax, wptr ems_offset         ; Load 32-byte offset
 098C  8B 16 0328 R		                mov     dx, wptr ems_offset + 2
 0990  8B D8			                mov     bx, ax                      ; Save a copy of ax (low 16 bits)
 0992  25 3FFF			                and     ax, 0011111111111111b       ; Get (ax & (16K - 1)), this is the offset (14 b
				its)
 0995  A3 0322 R		                mov     wptr EMS_to_o, ax           ; Save page offset
 0998  B1 0E			                mov     cl, 14
 099A  D3 EB			                shr     bx, cl                      ; Move low 2 bits of page into low 2 bits of bx
 099C  B1 02			                mov     cl, 2
 099E  D3 E2			                shl     dx, cl                      ; Move hi ? bits of page into dx shl 2
 09A0  0B D3			                or      dx, bx                      ; DX = page number (combine two values)
 09A2  89 16 0324 R		                mov     wptr EMS_to_s, dx           ; Save
				
 09A6  A1 0314 R		                mov     ax, wptr EMS_size           ; Retrieve size of copy
 09A9  8B 16 0316 R		                mov     dx, wptr EMS_size + 2
 09AD  01 06 0326 R		                add     wptr ems_offset, ax         ; Update EMS copy pointer
 09B1  11 16 0328 R		                adc     wptr ems_offset + 2, dx     ;  for next EMS write
				
 09B5  BE 0314 R		do_ems_write:   mov     si, offset @code:EMS_struc  ; DS:SI -> EMS request structure
 09B8  B8 5700			                mov     ax, 5700h                   ; Function 57 (copy/exchange memory), sub 0, cop
				y memory
 09BB  CD 67			                int     67h                         ; Call EMS manager
 09BD  0A E4			                or      ah, ah                      ; AH = 0 means success
 09BF  75 03			                jnz     save_ems_seg_er             ; Not 0 means error
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-31


				
 09C1  F8			save_ems_seg_ok:clc                                 ; Signal success
 09C2  EB 01			                jmp     short save_ems_seg_ret
				
 09C4  F9			save_ems_seg_er:stc
				
 09C5				save_ems_seg_ret:
 09C5  07			                pop     es
 09C6  1F			                pop     ds
 09C7  C3			                ret
 09C8				save_ems_seg    endp
				ENDIF
				; *****************************************************************************
				
				
				; *****************************************************************************
				; save_disk     Attempts to save program to DOS disk file
				;
				; Entry:        DS points to our variables
				;
				; Return:       Carry set on error, carry clear on success
				;               If successful, updates restore_proc with the address of
				;               the disk restore routine
				; *****************************************************************************
				IFDEF USE_DISK
 09C8				save_disk       proc    near
 09C8  06			                push    es
				
				                assume  ds:@code                ; Tell MASM DS points to our variables
				
 09C9  BA 032A R		creat_file:     mov     dx, offset @code:fname  ; DS:DX -> file name
 09CC  B4 3C			                mov     ah, 3Ch                 ; Create/truncate file
 09CE  B9 0002			                mov     cx, 02h                 ; Create a hidden file
 09D1  CD 21			                int     21h                     ; Call DOS
 09D3  72 4C			                jc      save_disk_er            ; Carry set, couldn't create file
				
 09D5  A3 0052 R		creat_ok:       mov     wptr handle, ax         ; Save handle returned by DOS
				
				; First, attempt to save the portion of the program block
 09D8  A1 000E R		disk_prog_save: mov     ax, wptr start_seg      ; Released segment address
 09DB  8E C0			                mov     es, ax
 09DD  A1 0006 R		                mov     ax, wptr prog_size      ; Size (in paragraphs) of program block
 09E0  E8 0A24 R		                call    save_disk_seg           ; Attempt to save the program block
 09E3  72 20			                jc      disk_write_er           ; Carry flag set == error
				
				IFNDEF NOFRAG
				; Next, save the extra DOS segments
 09E5				disk_extra_save:
 09E5  8B 0E 0010 R		                mov     cx, wptr extra_count    ; Number of extra blocks to save
 09E9  E3 25			                jcxz    save_disk_ok            ; If CX = 0, we exit routine
				
 09EB  BF 0012 R		                mov     di, offset dos_blocks   ; DI -> array of segment/size pairs
				
 09EE				disk_extra_save_loop:
 09EE  8B 05			                mov     ax, wptr [di].block_seg
 09F0  8E C0			                mov     es, ax                  ; ES = segment to save
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-32


 09F2  8B 45 02			                mov     ax, wptr [di].block_size; AX = size in paragraphs
 09F5  51			                push    cx
 09F6  57			                push    di
 09F7  E8 0A24 R		                call    save_disk_seg           ; Attempt to save this block
 09FA  5F			                pop     di
 09FB  59			                pop     cx
 09FC  72 07			                jc      disk_write_er           ; Carry flag set == error
 09FE  83 C7 04			                add     di, size dos_block
 0A01  E2 EB			                loop    disk_extra_save_loop    ; Keep going through all blocks
				
				ENDIF
 0A03  EB 0B			                jmp     short save_disk_ok
				
				
 0A05  B4 3E			disk_write_er:  mov     ah, 3Eh                 ; Close file first
 0A07  8B 1E 0052 R		                mov     bx, wptr handle
 0A0B  CD 21			                int     21h
 0A0D  F9			                stc
 0A0E  EB 12			                jmp     short save_disk_ret
				
				
 0A10  B4 3E			save_disk_ok:   mov     ah, 3Eh                 ; 3eh = close file
 0A12  8B 1E 0052 R		                mov     bx, wptr handle
 0A16  CD 21			                int     21h
 0A18  C7 06 02D0 R 04BC R	                mov     wptr restore_proc, offset @code:restore_disk    ; Initialize pointer
 0A1E  F8			                clc                                                     ;  to restore routine
 0A1F  EB 01			                jmp     short save_disk_ret
				
 0A21  F9			save_disk_er:   stc
				
 0A22  07			save_disk_ret:  pop     es
 0A23  C3			                ret
 0A24				save_disk       endp
				
				
				; *****************************************************************************
				; save_disk_seg Attempts to save a chunk of RAM to DOS disk file
				;
				; Entry:        ES points to the segment to save
				;               AX contains its length (in paragraphs)
				;               handle holds the file handle to write to
				;
				;
				; Return:       Carry set on error, carry clear on success
				; *****************************************************************************
 0A24				save_disk_seg   proc    near
 0A24  1E			                push    ds
 0A25  06			                push    es
 0A26  57			                push    di
				
				                assume  ds:@code
				
 0A27  A3 037A R		                mov     wptr paras_left, ax     ; Used to count paras written
 0A2A  8C C3			                mov     bx, es
 0A2C  8E DB			                mov     ds, bx                  ; DS -> segment to write
				
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Page     1-33


				                assume  ds:nothing
				
 0A2E  3D 0800			disk_write_32k: cmp     ax, 0800h               ; paras_left less than 32K?
 0A31  72 24			                jb      finish_disk_write       ; Yes, exit
 0A33  2E: 81 2E 037A R 0800	                sub     wptr cs:paras_left, 800h; We will write 32K bytes now
				
 0A3A  B4 40			                mov     ah, 40h                 ; DOS function to write to file
 0A3C  2E: 8B 1E 0052 R		                mov     bx, wptr cs:handle      ; BX = file handle to write to
 0A41  B9 8000			                mov     cx, 8000h               ; Write 32K bytes
 0A44  33 D2			                xor     dx, dx                  ; DS:DX is buffer to write
 0A46  CD 21			                int     21h                     ; Write data to file
 0A48  72 23			                jc      save_disk_seg_er        ; This write failed--escape
				
 0A4A  8C D8			disk_write_ok:  mov     ax, ds                  ; Move write pointer in memory
 0A4C  05 0800			                add     ax, 800h                ; We just wrote 1K paragraphs
 0A4F  8E D8			                mov     ds, ax
 0A51  2E: A1 037A R		                mov     ax, wptr cs:paras_left  ; AX checked above
 0A55  EB D7			                jmp     short disk_write_32k    ; Loop on next 32K
				
 0A57				finish_disk_write:
 0A57  B1 04			                mov     cl, 4                   ; AX = # paragraphs left to write
 0A59  D3 E0			                shl     ax, cl                  ; Paragraphs to bytes
 0A5B  8B C8			                mov     cx, ax
 0A5D  B4 40			                mov     ah, 40h                 ; 40h = write to file
 0A5F  2E: 8B 1E 0052 R		                mov     bx, wptr cs:handle      ; BX = file handle to write to
 0A64  33 D2			                xor     dx, dx                  ; DS:DX = buffer
 0A66  CD 21			                int     21h                     ; Call DOS
 0A68  72 03			                jc      save_disk_seg_er        ; Carry set, error (close file first)
				
 0A6A				save_disk_seg_ok:
				
 0A6A  F8			                clc
 0A6B  EB 01			                jmp     short save_disk_seg_ret
				
 0A6D				save_disk_seg_er:
 0A6D  F9			                stc
				
 0A6E				save_disk_seg_ret:
 0A6E  5F			                pop     di
 0A6F  07			                pop     es
 0A70  1F			                pop     ds
				
 0A71  C3			                ret
 0A72				save_disk_seg   endp
				
				
				
				ENDIF
				; *****************************************************************************
				
				END
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Symbols-1


Structures and Records:

                N a m e                 Width   # fields
                                        Shift   Width   Mask    Initial

DOS_BLOCK  . . . . . . . . . . .  	0004	0002
  BLOCK_SEG  . . . . . . . . . .  	0000
  BLOCK_SIZE . . . . . . . . . .  	0002

Segments and Groups:

                N a m e         	Length	 Align	Combine Class

DGROUP . . . . . . . . . . . . .  	GROUP
  _DATA  . . . . . . . . . . . .  	0000	WORD	PUBLIC	'DATA'
SWAP_TEXT  . . . . . . . . . . .  	0A72	WORD	PUBLIC	'CODE'

Symbols:            

                N a m e         	Type	 Value	 Attr

ABORT_LEN  . . . . . . . . . . .  	L WORD	02F5	SWAP_TEXT
ABORT_MSG  . . . . . . . . . . .  	L BYTE	02D2	SWAP_TEXT
ALLOC_EXTRA_LOOP . . . . . . . .  	L NEAR	05C5	SWAP_TEXT
ARGS_LOCATED . . . . . . . . . .  	L NEAR	0675	SWAP_TEXT

BPTR . . . . . . . . . . . . . .  	TEXT  byte ptr		

calc_size  . . . . . . . . . . .  	N PROC	074F	SWAP_TEXT	Global	Length = 0074
CALC_SIZE_RET  . . . . . . . . .  	L NEAR	07C1	SWAP_TEXT
CHECK_ALLOC  . . . . . . . . . .  	L NEAR	05D2	SWAP_TEXT
CHECK_NEXT_MCB . . . . . . . . .  	L NEAR	0787	SWAP_TEXT
CLOSE_READ . . . . . . . . . . .  	L NEAR	04F7	SWAP_TEXT
CMDLINE  . . . . . . . . . . . .  	TEXT  WORD PTR [BP]+8		
CMD_END  . . . . . . . . . . . .  	L NEAR	0624	SWAP_TEXT
CMD_LEN  . . . . . . . . . . . .  	L BYTE	0219	SWAP_TEXT
CMD_LINE . . . . . . . . . . . .  	L BYTE	021A	SWAP_TEXT	Length = 0080
CMD_LOOP . . . . . . . . . . . .  	L NEAR	0617	SWAP_TEXT
CMD_OFS  . . . . . . . . . . . .  	L WORD	029C	SWAP_TEXT
CMD_PAD  . . . . . . . . . . . .  	L BYTE	0218	SWAP_TEXT
CMD_SEG  . . . . . . . . . . . .  	L WORD	029E	SWAP_TEXT
CREAT_FILE . . . . . . . . . . .  	L NEAR	09C9	SWAP_TEXT
CREAT_OK . . . . . . . . . . . .  	L NEAR	09D5	SWAP_TEXT
C_L_LENGTH . . . . . . . . . . .  	L WORD	02A8	SWAP_TEXT

DISK_EXTRA_REST  . . . . . . . .  	L NEAR	04D9	SWAP_TEXT
DISK_EXTRA_REST_LOOP . . . . . .  	L NEAR	04E2	SWAP_TEXT
DISK_EXTRA_SAVE  . . . . . . . .  	L NEAR	09E5	SWAP_TEXT
DISK_EXTRA_SAVE_LOOP . . . . . .  	L NEAR	09EE	SWAP_TEXT
DISK_PROG_REST . . . . . . . . .  	L NEAR	04CC	SWAP_TEXT
DISK_PROG_SAVE . . . . . . . . .  	L NEAR	09D8	SWAP_TEXT
DISK_READ_32K  . . . . . . . . .  	L NEAR	051C	SWAP_TEXT
DISK_READ_OK . . . . . . . . . .  	L NEAR	0538	SWAP_TEXT
DISK_WRITE_32K . . . . . . . . .  	L NEAR	0A2E	SWAP_TEXT
DISK_WRITE_ER  . . . . . . . . .  	L NEAR	0A05	SWAP_TEXT
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Symbols-2


DISK_WRITE_OK  . . . . . . . . .  	L NEAR	0A4A	SWAP_TEXT
DOS_BLOCKS . . . . . . . . . . .  	L DWORD	0012	SWAP_TEXT	Length = 0010
DO_EMS_READ  . . . . . . . . . .  	L NEAR	04A9	SWAP_TEXT
DO_EMS_WRITE . . . . . . . . . .  	L NEAR	09B5	SWAP_TEXT
do_exec  . . . . . . . . . . . .  	F PROC	05A2	SWAP_TEXT	Global	Length = 0046
DO_XMS_READ  . . . . . . . . . .  	L NEAR	03E7	SWAP_TEXT
DO_XMS_WRITE . . . . . . . . . .  	L NEAR	08C9	SWAP_TEXT
DPTR . . . . . . . . . . . . . .  	TEXT  dword ptr		

EMM_INT  . . . . . . . . . . . .  	NUMBER	0067	
EMM_NAME . . . . . . . . . . . .  	L BYTE	030C	SWAP_TEXT
EMM_NAME_LEN . . . . . . . . . .  	NUMBER	0008	
ems4_installed . . . . . . . . .  	F PROC	07EB	SWAP_TEXT	Global	Length = 0030
EMS4_YES . . . . . . . . . . . .  	L NEAR	080F	SWAP_TEXT
EMS_ALLOC_OK . . . . . . . . . .  	L NEAR	090F	SWAP_TEXT
EMS_DEALLOC  . . . . . . . . . .  	L NEAR	0441	SWAP_TEXT
EMS_EXTRA_REST . . . . . . . . .  	L NEAR	0423	SWAP_TEXT
EMS_EXTRA_REST_LOOP  . . . . . .  	L NEAR	042C	SWAP_TEXT
EMS_EXTRA_SAVE . . . . . . . . .  	L NEAR	092A	SWAP_TEXT
EMS_EXTRA_SAVE_LOOP  . . . . . .  	L NEAR	0933	SWAP_TEXT
EMS_FROM . . . . . . . . . . . .  	L BYTE	0318	SWAP_TEXT
EMS_FROM_H . . . . . . . . . . .  	L WORD	0319	SWAP_TEXT
EMS_FROM_O . . . . . . . . . . .  	L WORD	031B	SWAP_TEXT
EMS_FROM_S . . . . . . . . . . .  	L WORD	031D	SWAP_TEXT
EMS_INST . . . . . . . . . . . .  	L NEAR	08F8	SWAP_TEXT
EMS_NO . . . . . . . . . . . . .  	L NEAR	0814	SWAP_TEXT
EMS_OFFSET . . . . . . . . . . .  	L DWORD	0326	SWAP_TEXT
EMS_PROG_REST  . . . . . . . . .  	L NEAR	040C	SWAP_TEXT
EMS_PROG_SAVE  . . . . . . . . .  	L NEAR	0913	SWAP_TEXT
EMS_READ_FROM  . . . . . . . . .  	L NEAR	0472	SWAP_TEXT
EMS_READ_SIZE  . . . . . . . . .  	L NEAR	0453	SWAP_TEXT
EMS_READ_TO  . . . . . . . . . .  	L NEAR	045F	SWAP_TEXT
EMS_RET  . . . . . . . . . . . .  	L NEAR	0816	SWAP_TEXT
EMS_SIZE . . . . . . . . . . . .  	L DWORD	0314	SWAP_TEXT
EMS_STRUC  . . . . . . . . . . .  	L BYTE	0314	SWAP_TEXT
EMS_TO . . . . . . . . . . . . .  	L BYTE	031F	SWAP_TEXT
EMS_TO_H . . . . . . . . . . . .  	L WORD	0320	SWAP_TEXT
EMS_TO_O . . . . . . . . . . . .  	L WORD	0322	SWAP_TEXT
EMS_TO_S . . . . . . . . . . . .  	L WORD	0324	SWAP_TEXT
EMS_WRITE_FROM . . . . . . . . .  	L NEAR	096B	SWAP_TEXT
EMS_WRITE_SIZE . . . . . . . . .  	L NEAR	095F	SWAP_TEXT
EMS_WRITE_TO . . . . . . . . . .  	L NEAR	097E	SWAP_TEXT
EMS_YES  . . . . . . . . . . . .  	L NEAR	0807	SWAP_TEXT
ENV_SEG  . . . . . . . . . . . .  	L WORD	029A	SWAP_TEXT
err_exit . . . . . . . . . . . .  	N PROC	058B	SWAP_TEXT	Global	Length = 0017
execute_program  . . . . . . . .  	N PROC	0560	SWAP_TEXT	Global	Length = 002B
EXEC_ER  . . . . . . . . . . . .  	L NEAR	05A7	SWAP_TEXT
EXEC_ERR . . . . . . . . . . . .  	L NEAR	0581	SWAP_TEXT
EXEC_EXIT  . . . . . . . . . . .  	L NEAR	0588	SWAP_TEXT
EXEC_PAD . . . . . . . . . . . .  	L BYTE	02CF	SWAP_TEXT
EXEC_PROG  . . . . . . . . . . .  	L NEAR	0727	SWAP_TEXT
EXEC_PROGRAM . . . . . . . . . .  	L NEAR	0562	SWAP_TEXT
EXEC_RET . . . . . . . . . . . .  	L BYTE	02CE	SWAP_TEXT
EXIT_SWAP  . . . . . . . . . . .  	L NEAR	072C	SWAP_TEXT
EXTRA_COUNT  . . . . . . . . . .  	L WORD	0010	SWAP_TEXT

Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Symbols-3


FCB5C  . . . . . . . . . . . . .  	L BYTE	02AE	SWAP_TEXT
FCB5C_DRIVE  . . . . . . . . . .  	L BYTE	02AE	SWAP_TEXT
FCB5C_EXT  . . . . . . . . . . .  	L BYTE	02B7	SWAP_TEXT	Length = 0003
FCB5C_FNAME  . . . . . . . . . .  	L BYTE	02AF	SWAP_TEXT	Length = 0008
FCB5C_PAD  . . . . . . . . . . .  	L BYTE	02BA	SWAP_TEXT	Length = 0004
FCB6C  . . . . . . . . . . . . .  	L BYTE	02BE	SWAP_TEXT
FCB6C_DRIVE  . . . . . . . . . .  	L BYTE	02BE	SWAP_TEXT
FCB6C_EXT  . . . . . . . . . . .  	L BYTE	02C7	SWAP_TEXT	Length = 0003
FCB6C_FNAME  . . . . . . . . . .  	L BYTE	02BF	SWAP_TEXT	Length = 0008
FCB6C_PAD  . . . . . . . . . . .  	L BYTE	02CA	SWAP_TEXT	Length = 0004
FCB_5C_OFS . . . . . . . . . . .  	L WORD	02A0	SWAP_TEXT
FCB_5C_SEG . . . . . . . . . . .  	L WORD	02A2	SWAP_TEXT
FCB_6C_OFS . . . . . . . . . . .  	L WORD	02A4	SWAP_TEXT
FCB_6C_SEG . . . . . . . . . . .  	L WORD	02A6	SWAP_TEXT
FIND_EXTRAS  . . . . . . . . . .  	L NEAR	077A	SWAP_TEXT
FINISH_DISK_WRITE  . . . . . . .  	L NEAR	0A57	SWAP_TEXT
FNAME  . . . . . . . . . . . . .  	L BYTE	032A	SWAP_TEXT	Length = 0050
FREE_EXTRA_LOOP  . . . . . . . .  	L NEAR	0709	SWAP_TEXT

GET_CMD  . . . . . . . . . . . .  	L NEAR	060F	SWAP_TEXT
GET_EMM_VECTOR . . . . . . . . .  	L NEAR	07EF	SWAP_TEXT
GET_FILE . . . . . . . . . . . .  	L NEAR	0690	SWAP_TEXT
GET_NAME . . . . . . . . . . . .  	L NEAR	0603	SWAP_TEXT
GET_RETURN . . . . . . . . . . .  	L NEAR	0577	SWAP_TEXT
GET_VECTOR . . . . . . . . . . .  	NUMBER	0035	

HANDLE . . . . . . . . . . . . .  	L WORD	0052	SWAP_TEXT

IS_MY_BLOCK  . . . . . . . . . .  	L NEAR	07A2	SWAP_TEXT
IS_MY_BLOCK2 . . . . . . . . . .  	L NEAR	07AD	SWAP_TEXT

LAST_DISK_READ . . . . . . . . .  	L NEAR	0545	SWAP_TEXT

MAX_DOS_CMD  . . . . . . . . . .  	NUMBER	007F	
MAX_EXTRA  . . . . . . . . . . .  	NUMBER	0010	
MCB_PSP  . . . . . . . . . . . .  	L WORD	000C	SWAP_TEXT
MY_BLOCK . . . . . . . . . . . .  	L NEAR	079B	SWAP_TEXT
MY_PSP . . . . . . . . . . . . .  	L WORD	000A	SWAP_TEXT

NAME_LOOP  . . . . . . . . . . .  	L NEAR	0609	SWAP_TEXT
NEW_MCB  . . . . . . . . . . . .  	L BYTE	05E8	SWAP_TEXT	Length = 0010
NEW_SIZE . . . . . . . . . . . .  	L WORD	0004	SWAP_TEXT
NEW_SP . . . . . . . . . . . . .  	L WORD	0198	SWAP_TEXT
NEW_STACK  . . . . . . . . . . .  	L BYTE	0058	SWAP_TEXT	Length = 0140
NEXT_MCB2  . . . . . . . . . . .  	L NEAR	078F	SWAP_TEXT
NO_SAVE  . . . . . . . . . . . .  	L NEAR	06E9	SWAP_TEXT
NO_SHRINK  . . . . . . . . . . .  	L NEAR	071F	SWAP_TEXT
NO_XMS . . . . . . . . . . . . .  	L NEAR	07E4	SWAP_TEXT

OLD_SIZE . . . . . . . . . . . .  	L WORD	0002	SWAP_TEXT
OLD_SP . . . . . . . . . . . . .  	L WORD	0054	SWAP_TEXT
OLD_SS . . . . . . . . . . . . .  	L WORD	0056	SWAP_TEXT
OPEN_FILE  . . . . . . . . . . .  	L NEAR	04BD	SWAP_TEXT
OPEN_OK  . . . . . . . . . . . .  	L NEAR	04C9	SWAP_TEXT
OUR_STACK  . . . . . . . . . . .  	L NEAR	06B3	SWAP_TEXT

Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Symbols-4


PAGES_USED . . . . . . . . . . .  	L BYTE	030B	SWAP_TEXT
PARAM_BLK  . . . . . . . . . . .  	L BYTE	029A	SWAP_TEXT
PARAS_LEFT . . . . . . . . . . .  	L WORD	037A	SWAP_TEXT
para_align . . . . . . . . . . .  	N PROC	05E8	SWAP_TEXT	Global	Length = 0010
POINT_SEGS . . . . . . . . . . .  	L NEAR	05FF	SWAP_TEXT
PREV_STACK . . . . . . . . . . .  	L NEAR	072F	SWAP_TEXT
PROG . . . . . . . . . . . . . .  	TEXT  WORD PTR [BP]+6		
PROG_NAME  . . . . . . . . . . .  	L BYTE	0198	SWAP_TEXT	Length = 0080
PROG_SIZE  . . . . . . . . . . .  	L WORD	0006	SWAP_TEXT
PSP_ERROR  . . . . . . . . . . .  	L NEAR	06D9	SWAP_TEXT
PSP_OK . . . . . . . . . . . . .  	L NEAR	06E1	SWAP_TEXT

RESIZE_ERR . . . . . . . . . . .  	L NEAR	05DE	SWAP_TEXT
RESOLVE  . . . . . . . . . . . .  	L NEAR	0696	SWAP_TEXT
restore_disk . . . . . . . . . .  	N PROC	04BC	SWAP_TEXT	Global	Length = 0056
RESTORE_DISK_ER  . . . . . . . .  	L NEAR	04FE	SWAP_TEXT
RESTORE_DISK_OK  . . . . . . . .  	L NEAR	04FB	SWAP_TEXT
RESTORE_DISK_RET . . . . . . . .  	L NEAR	0503	SWAP_TEXT
restore_ems  . . . . . . . . . .  	N PROC	040B	SWAP_TEXT	Global	Length = 0046
RESTORE_EMS_RET  . . . . . . . .  	L NEAR	044F	SWAP_TEXT
RESTORE_PROC . . . . . . . . . .  	L WORD	02D0	SWAP_TEXT
RESTORE_PROG . . . . . . . . . .  	L NEAR	05E1	SWAP_TEXT
restore_xms  . . . . . . . . . .  	N PROC	037C	SWAP_TEXT	Global	Length = 0048
RESTORE_XMS_RET  . . . . . . . .  	L NEAR	03C2	SWAP_TEXT
rest_disk_seg  . . . . . . . . .  	N PROC	0512	SWAP_TEXT	Global	Length = 004E
REST_DISK_SEG_ER . . . . . . . .  	L NEAR	055C	SWAP_TEXT
REST_DISK_SEG_OK . . . . . . . .  	L NEAR	0559	SWAP_TEXT
REST_DISK_SEG_RET  . . . . . . .  	L NEAR	055D	SWAP_TEXT
rest_ems_seg . . . . . . . . . .  	N PROC	0451	SWAP_TEXT	Global	Length = 006B
REST_EMS_SEG_ER  . . . . . . . .  	L NEAR	04B8	SWAP_TEXT
REST_EMS_SEG_OK  . . . . . . . .  	L NEAR	04B5	SWAP_TEXT
REST_EMS_SEG_RET . . . . . . . .  	L NEAR	04B9	SWAP_TEXT
rest_xms_seg . . . . . . . . . .  	N PROC	03C4	SWAP_TEXT	Global	Length = 0047
REST_XMS_SEG_ER  . . . . . . . .  	L NEAR	0407	SWAP_TEXT
REST_XMS_SEG_OK  . . . . . . . .  	L NEAR	03F5	SWAP_TEXT
REST_XMS_SEG_RET . . . . . . . .  	L NEAR	0408	SWAP_TEXT
RETURN . . . . . . . . . . . . .  	TEXT  WORD PTR [BP]+10		
RET_CODE . . . . . . . . . . . .  	L WORD	0000	SWAP_TEXT
RE_SIZE  . . . . . . . . . . . .  	L NEAR	05AD	SWAP_TEXT

save_disk  . . . . . . . . . . .  	N PROC	09C8	SWAP_TEXT	Global	Length = 005C
SAVE_DISK_ER . . . . . . . . . .  	L NEAR	0A21	SWAP_TEXT
SAVE_DISK_OK . . . . . . . . . .  	L NEAR	0A10	SWAP_TEXT
SAVE_DISK_RET  . . . . . . . . .  	L NEAR	0A22	SWAP_TEXT
save_disk_seg  . . . . . . . . .  	N PROC	0A24	SWAP_TEXT	Global	Length = 004E
SAVE_DISK_SEG_ER . . . . . . . .  	L NEAR	0A6D	SWAP_TEXT
SAVE_DISK_SEG_OK . . . . . . . .  	L NEAR	0A6A	SWAP_TEXT
SAVE_DISK_SEG_RET  . . . . . . .  	L NEAR	0A6E	SWAP_TEXT
save_ems . . . . . . . . . . . .  	N PROC	08ED	SWAP_TEXT	Global	Length = 0070
SAVE_EMS_ER  . . . . . . . . . .  	L NEAR	095B	SWAP_TEXT
SAVE_EMS_FAIL  . . . . . . . . .  	L NEAR	094A	SWAP_TEXT
SAVE_EMS_OK  . . . . . . . . . .  	L NEAR	0952	SWAP_TEXT
SAVE_EMS_RET . . . . . . . . . .  	L NEAR	095C	SWAP_TEXT
save_ems_seg . . . . . . . . . .  	N PROC	095D	SWAP_TEXT	Global	Length = 006B
SAVE_EMS_SEG_ER  . . . . . . . .  	L NEAR	09C4	SWAP_TEXT
SAVE_EMS_SEG_OK  . . . . . . . .  	L NEAR	09C1	SWAP_TEXT
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Symbols-5


SAVE_EMS_SEG_RET . . . . . . . .  	L NEAR	09C5	SWAP_TEXT
SAVE_ER  . . . . . . . . . . . .  	L NEAR	082E	SWAP_TEXT
SAVE_FILE  . . . . . . . . . . .  	TEXT  WORD PTR [BP]+12		
SAVE_INFO  . . . . . . . . . . .  	L NEAR	06C3	SWAP_TEXT
SAVE_OK  . . . . . . . . . . . .  	L NEAR	0831	SWAP_TEXT
save_program . . . . . . . . . .  	N PROC	081B	SWAP_TEXT	Global	Length = 001C
SAVE_REGS  . . . . . . . . . . .  	L NEAR	06BC	SWAP_TEXT
SAVE_RET . . . . . . . . . . . .  	L NEAR	0832	SWAP_TEXT
SAVE_STACK . . . . . . . . . . .  	L NEAR	06A7	SWAP_TEXT
save_xms . . . . . . . . . . . .  	N PROC	0837	SWAP_TEXT	Global	Length = 006F
SAVE_XMS_ER  . . . . . . . . . .  	L NEAR	089B	SWAP_TEXT
SAVE_XMS_OK  . . . . . . . . . .  	L NEAR	089E	SWAP_TEXT
SAVE_XMS_RET . . . . . . . . . .  	L NEAR	08A5	SWAP_TEXT
save_xms_seg . . . . . . . . . .  	N PROC	08A6	SWAP_TEXT	Global	Length = 0047
SAVE_XMS_SEG_ER  . . . . . . . .  	L NEAR	08E9	SWAP_TEXT
SAVE_XMS_SEG_OK  . . . . . . . .  	L NEAR	08D7	SWAP_TEXT
SAVE_XMS_SEG_RET . . . . . . . .  	L NEAR	08EA	SWAP_TEXT
SHRINK_MEM . . . . . . . . . . .  	L NEAR	06F1	SWAP_TEXT
SI_5C  . . . . . . . . . . . . .  	L WORD	02AA	SWAP_TEXT
SI_6C  . . . . . . . . . . . . .  	L WORD	02AC	SWAP_TEXT
START_SEG  . . . . . . . . . . .  	L WORD	000E	SWAP_TEXT
STDERR . . . . . . . . . . . . .  	NUMBER	0002	
swap . . . . . . . . . . . . . .  	F PROC	05F8	SWAP_TEXT	Global	Length = 0157

TOTAL_PARAS  . . . . . . . . . .  	L WORD	0008	SWAP_TEXT
TRY_SAVE . . . . . . . . . . . .  	L NEAR	06E4	SWAP_TEXT

USE_DISK . . . . . . . . . . . .  	NUMBER	0001	
USE_EMS  . . . . . . . . . . . .  	NUMBER	0001	
USE_XMS  . . . . . . . . . . . .  	NUMBER	0001	

WPTR . . . . . . . . . . . . . .  	TEXT  word ptr		
WRITE_ERROR  . . . . . . . . . .  	L NEAR	0891	SWAP_TEXT

XMS_ALLOC  . . . . . . . . . . .  	L NEAR	084B	SWAP_TEXT
XMS_ALLOC_OK . . . . . . . . . .  	L NEAR	0856	SWAP_TEXT
XMS_DEALLOC  . . . . . . . . . .  	L NEAR	03B2	SWAP_TEXT
XMS_EXTRA_REST . . . . . . . . .  	L NEAR	0394	SWAP_TEXT
XMS_EXTRA_REST_LOOP  . . . . . .  	L NEAR	039D	SWAP_TEXT
XMS_EXTRA_SAVE . . . . . . . . .  	L NEAR	0871	SWAP_TEXT
XMS_EXTRA_SAVE_LOOP  . . . . . .  	L NEAR	087A	SWAP_TEXT
XMS_FROM . . . . . . . . . . . .  	L WORD	02FF	SWAP_TEXT
XMS_FROM_ADDR  . . . . . . . . .  	L DWORD	0301	SWAP_TEXT
XMS_INST . . . . . . . . . . . .  	L NEAR	0842	SWAP_TEXT
xms_installed  . . . . . . . . .  	F PROC	07C3	SWAP_TEXT	Global	Length = 0028
XMS_PROC . . . . . . . . . . . .  	L DWORD	02F7	SWAP_TEXT
XMS_PROG_REST  . . . . . . . . .  	L NEAR	037D	SWAP_TEXT
XMS_PROG_SAVE  . . . . . . . . .  	L NEAR	085A	SWAP_TEXT
XMS_READ_FROM  . . . . . . . . .  	L NEAR	03D2	SWAP_TEXT
XMS_READ_SIZE  . . . . . . . . .  	L NEAR	03C6	SWAP_TEXT
XMS_READ_TO  . . . . . . . . . .  	L NEAR	03D8	SWAP_TEXT
XMS_RET  . . . . . . . . . . . .  	L NEAR	07E6	SWAP_TEXT
XMS_SIZE . . . . . . . . . . . .  	L DWORD	02FB	SWAP_TEXT
XMS_STRUC  . . . . . . . . . . .  	L BYTE	02FB	SWAP_TEXT
XMS_TO . . . . . . . . . . . . .  	L WORD	0305	SWAP_TEXT
XMS_TO_ADDR  . . . . . . . . . .  	L DWORD	0307	SWAP_TEXT
Microsoft (R) Macro Assembler Version 5.10                  3/11/93 15:53:13
                                                             Symbols-6


XMS_WRITE_FROM . . . . . . . . .  	L NEAR	08B4	SWAP_TEXT
XMS_WRITE_SIZE . . . . . . . . .  	L NEAR	08A8	SWAP_TEXT
XMS_WRITE_TO . . . . . . . . . .  	L NEAR	08C3	SWAP_TEXT

YES_XMS  . . . . . . . . . . . .  	L NEAR	07D0	SWAP_TEXT

@CODE  . . . . . . . . . . . . .  	TEXT  swap_TEXT		
@CODESIZE  . . . . . . . . . . .  	TEXT  1		
@CPU . . . . . . . . . . . . . .  	TEXT  0101h		
@DATASIZE  . . . . . . . . . . .  	TEXT  0		
@FILENAME  . . . . . . . . . . .  	TEXT  swap		
@VERSION . . . . . . . . . . . .  	TEXT  510		
_MEDIUM  . . . . . . . . . . . .  	TEXT  		


   1890 Source  Lines
   1890 Total   Lines
    263 Symbols

  46620 + 371353 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
